---
title: é‡æ–°å­¦ä¹  Solidity
date: 2018-03-08 16:25:00
tags:
- Ethereum 
- åŒºå—é“¾
---
ä»¥ä¸‹å†…å®¹è¿˜æ˜¯ä» Solidity æ–‡æ¡£é‡Œæ‘˜å‡ºæ¥çš„ã€‚

## æ™ºèƒ½åˆçº¦å…¥é—¨/ä»‹ç» ##

### ç¬¬ä¸€ä¸ªåŸºæœ¬çš„ä¾‹å­ ###

```javascripts
pragma solidity ^0.4.0;

contract SimpleStorage {
    uint storedData;

    function set(uint x) public {
        storedData = x;
    }

    function get() public constant returns (uint) {
        return storedData;
    }
}
```

ä¸€ä¸ª contract å¯ä»¥è¢«è®¤ä¸ºæ˜¯ä¸€ä¸ªç±»å‹ã€‚
é»˜è®¤çš„ unint å°±æ˜¯256ä½çš„ã€‚
storedData å¯ä»¥è¢«è®¤ä¸ºæ˜¯ state variableï¼ŒçŠ¶æ€å˜é‡ã€‚åœ¨ Solidity çš„æ¦‚å¿µé‡Œé¢ï¼Œè¿™ä¸ªä¸œè¥¿å¯ä»¥è¢«è®¤ä¸ºæ˜¯æ•°æ®åº“é‡Œé¢çš„ä¸€ä¸ªæ§½ï¼Œå¯ä»¥è¢«å‡½æ•°æŸ¥è¯¢å’Œä¿®æ”¹ã€‚æ³¨æ„çœ‹å®ƒä¸æ˜¯ public çš„ï¼Œæ‰€ä»¥æ²¡æœ‰åˆæˆæ–¹æ³•ã€‚

è®¿é—®çŠ¶æ€å˜é‡ä¸éœ€è¦ç”¨ thiså‰ç¼€ï¼ˆåœ¨ä»€ä¹ˆ scope ä¸‹éƒ½ä¸éœ€è¦å—ï¼Ÿï¼‰ã€‚

è¿™ä¸ªä¾‹å­æ²¡æœ‰é™åˆ¶ä»»ä½•å…¶ä»–äººè°ƒç”¨ä¿®æ”¹çŠ¶æ€å˜é‡çš„æ–¹æ³•ã€‚

### å­è´§å¸çš„ä¾‹å­ ###

```javascript
pragma solidity ^0.4.0;

contract Coin {
    // The keyword "public" makes those variables
    // readable from outside.
    address public minter;
    mapping (address => uint) public balances;

    // Events allow light clients to react on
    // changes efficiently.
    event Sent(address from, address to, uint amount);

    // This is the constructor whose code is
    // run only when the contract is created.
    function Coin() public {
        minter = msg.sender;
    }

    function mint(address receiver, uint amount) public {
        if (msg.sender != minter) return;
        balances[receiver] += amount;
    }

    function send(address receiver, uint amount) public {
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Sent(msg.sender, receiver, amount);
    }
}
```

address æ˜¯160ä½çš„ç±»å‹ï¼ˆé—®ï¼šä¸ºä»€ä¹ˆä¸æ˜¯2çš„æ•´æ•°æ¬¡å¹‚ï¼Ÿå¦‚ä½•ï¼‰ã€‚å¯ä»¥ç”¨æ¥å­˜å‚¨åˆçº¦åœ°å€æˆ–è€…å±äºå¤–éƒ¨äººçš„é’¥åŒ™å¯¹ï¼ˆæ‰€è°“çš„ msg.senderï¼Ÿï¼‰ã€‚public å…³é”®å­—ä¼šè®©ç¼–è¯‘å™¨è‡ªåŠ¨å¸®å¿™ç”Ÿæˆä¸€ä¸ªè®¿é—®å™¨å‡½æ•°ï¼š
```javascript
function minter() returns (address) { return minter; }
```
è€Œ`mapping (address => uint) public balances`åˆ›é€ äº†ä¸€ä¸ªå…¬å…±çŠ¶æ€å˜é‡ï¼Œç”¨ hash è¡¨çš„å½¢å¼æ¥æŠŠåœ°å€æ˜ å°„åˆ°æ•´æ•°ï¼Œå…¶å®å°±æ˜¯æŠŠæˆ·å¤´æ˜ å°„åˆ°é‡‘é’±ä½™é¢ã€‚è¿™ä¸€ä¸ªå…¬å…±å˜é‡è¢«**è™šæ‹Ÿåœ°åˆå§‹åŒ–**äº†ï¼Œæ‰€ä»¥æ‰€æœ‰åˆæ³•çš„key**éƒ½å­˜åœ¨**ï¼Œè€Œå®ƒä»¬æ˜ å°„valueéƒ½æ˜¯é›¶å€¼ï¼ˆå¯¹æ•´æ•°è€Œè¨€ï¼Œå½“ç„¶åº”è¯¥æ˜¯0ï¼‰ã€‚å› ä¸ºè¿™ä¸ªæ— é™å¤§çš„ map çš„å­˜åœ¨ï¼Œæ‰€ä»¥ä¸å¯èƒ½éå†æ‰€æœ‰çš„ keyï¼Œä¹Ÿä¸èƒ½éå†æ‰€æœ‰çš„ valueï¼Œåªèƒ½ä¾èµ–äºå¤–éƒ¨æ•°ç»„æ¥è®°ä½æœ‰æ„ä¹‰çš„ keyã€‚è€Œç¼–è¯‘å™¨å¸®å¿™ç”Ÿæˆçš„å‡½æ•°ï¼Œåˆ™çœ‹èµ·æ¥æ˜¯è¿™ä¸ªæ ·å­çš„ï¼š
```javascript
function balances(address _account) public view returns (uint) {
    return balances[_account];
}
```

ä¹Ÿå°±æ˜¯è¯´ï¼Œè°ƒç”¨çš„æ—¶å€™ï¼Œç”¨ç±» balances(0x1234567)çš„æ–¹å¼æ¥è·å–è´¦æˆ·ä½™é¢ï¼Ÿ


Event çš„å®šä¹‰å’Œæˆ‘ä»¬ä¹ æƒ¯çš„å°±å¾ˆç›¸ä¼¼äº†ã€‚ä½†åŸæ–‡ä¸­ä¸¾äº†ä¸€ä¸ªè§‚å¯Ÿçš„ä¾‹å­ï¼Œä¸çŸ¥é“æ˜¯åœ¨ Web3 api é‡Œé¢ä½¿ç”¨ï¼Œè¿˜æ˜¯åœ¨æ™ºèƒ½åˆçº¦é‡Œé¢ä½¿ç”¨ï¼š
```javascript
Coin.Sent().watch({}, '', function(error, result) {
    if (!error) {
        console.log("Coin transfer: " + result.args.amount +
            " coins were sent from " + result.args.from +
            " to " + result.args.to + ".");
        console.log("Balances now:\n" +
            "Sender: " + Coin.balances.call(result.args.from) +
            "Receiver: " + Coin.balances.call(result.args.to));
    }
})
```
å½“ç„¶è¿™ä¸ªä¾‹å­ä¹Ÿæä¾›äº†å¯¹ balances å‡½æ•°çš„è°ƒç”¨ç¤ºä¾‹ã€‚

Coin å‡½æ•°å°±æ˜¯åœ¨åˆ›å»ºåˆçº¦çš„æ—¶å€™åªæ‰§è¡Œä¸€æ¬¡ä¸èƒ½å†è¢«æ‰§è¡Œçš„ã€‚è¿™ä¸ªæ„é€ å™¨å…¶å®æ˜¾å¼åœ°æŠŠåˆ›å»ºåˆçº¦çš„ msgï¼ˆè€Œä¸åªæ˜¯ senderï¼‰ä»¥åŠ tx å’Œ block è¿™æ ·çš„é»˜è®¤å˜é‡éƒ½ä¿å­˜ä¸‹æ¥äº†ã€‚å¯¹äºæ‰€æœ‰å‡½æ•°è€Œè¨€ï¼Œmsg.sender æ°¸è¿œæŒ‡å‘å½“å‰è¿™ä¸ªå‡½æ•°çš„è°ƒç”¨åœ°å€ã€‚

mint å› ä¸ºè®¾ç½®äº†å«è¯­å¥ï¼Œæ‰€ä»¥åœ¨ä¸æ˜¯åˆ›å»ºè€…çš„è°ƒç”¨é¢å‰ä¼šæå‰è¿”å›ã€‚è€Œ send åˆ™å¯ä»¥è¢«ä»»ä½•äººè°ƒç”¨ã€‚

è¿™äº›è½¬è´¦äº‹ä»¶å½“ç„¶ä¸å¯èƒ½è¢«é“¾è‡ªå¸¦çš„è´§å¸ç³»ç»Ÿåæ˜ å‡ºæ¥ã€‚ä½†å› ä¸ºè¿™ä¸ªåˆçº¦è‡ªå·±å¸¦äº†äº‹ä»¶ï¼Œæ‰€ä»¥å¯ä»¥å¼€å‘é’ˆå¯¹å®ƒçš„åŒºå—é“¾æµè§ˆå™¨ã€‚

### åŒºå—é“¾åŸºç¡€ ###

#### äº‹åŠ¡ ####

åŒºå—é“¾æ˜¯å…¨å±€å…±äº«çš„äº‹åŠ¡å‹æ•°æ®åº“ï¼Œä»¥å¤ªåŠç”šè‡³å¯ä»¥è¢«è®¤ä¸ºæ˜¯ä¸€ä¸ªåºåˆ—åŒ–éš”ç¦»çº§åˆ«çš„æ•°æ®åº“ã€‚æ‰€æœ‰åŠ å…¥ç½‘ç»œçš„äººéƒ½å¯ä»¥ä»è¿™ä¸ªæ•°æ®åº“é‡Œè¯»å–æ¡ç›®ã€‚å¦‚æœä½ æƒ³æ”¹å˜æ•°æ®åº“é‡Œçš„ä»€ä¹ˆğŸ‘»ä¸œè¥¿ï¼Œä½ åˆ›é€ çš„äº¤æ˜“å¿…é¡»è¢«æ‰€æœ‰äººæ¥å—ã€‚äº‹åŠ¡ï¼Œä¹Ÿå°±æ„å‘³ç€æ“ä½œæ˜¯åŸå­åŒ–çš„ï¼Œäº‹åŠ¡é‡Œçš„æ‰€æœ‰æ“ä½œè¦ä¹ˆéƒ½è¢«å®Œæˆï¼Œè¦ä¹ˆéƒ½æ²¡æ‰§è¡Œã€‚æ­¤å¤–ï¼Œæ²¡æœ‰äººèƒ½å¤Ÿç¯¡æ”¹å·²ç»è¢«åº”ç”¨æ•°æ®åº“é‡Œçš„äº‹åŠ¡ã€‚

åªæœ‰ç­¾è¿‡åçš„äº‹åŠ¡ï¼Œæ‰èƒ½åšç›¸åº”çš„ä¿®æ”¹--ç”¨å¯†ç å­¦å’Œæƒé™éš”ç¦»æ¥ä¿è¯å®‰å…¨æ€§ã€‚

#### åŒºå— ####

ä¸€ä¸ªéœ€è¦å…‹æœçš„ä¸»è¦éšœç¢æ˜¯ï¼ŒæŒ‰ç…§æ¯”ç‰¹å¸çš„è¯´æ³•ï¼Œæ˜¯æ‰€è°“çš„â€œåŒèŠ±æ”»å‡»â€ã€‚ä¹Ÿå°±æ˜¯å¦‚æœç½‘ç»œä¸­å­˜åœ¨ç›¸äº’çŸ›ç›¾çš„ä¸¤ç¬”äº‹åŠ¡æ€ä¹ˆåŠï¼Ÿ

æŠ½è±¡çš„å›ç­”æ˜¯ï¼Œä½ ä¸ç”¨æ‹…å¿ƒè¿™ä¸ªã€‚ä¸€ä¸ªäº‹åŠ¡çš„æ’åºæ€»ä¼šä¸ºä½ æŒ‘é€‰å‡ºæ¥ï¼Œï¼ˆè¢«é€‰ä¸­çš„ï¼‰äº‹åŠ¡ä¼šè¢«æ‰“åŒ…è¿›ä¸€ä¸ªæ‰€è°“çš„â€œåŒºå—â€é‡Œï¼Œç„¶åä»–ä»¬ä¼šè¢«æ‰§è¡Œå’Œåˆ†å‘åˆ°æ‰€æœ‰å‚ä¸èŠ‚ç‚¹é‡Œé¢ã€‚å¦‚æœä¸¤ä¸ªåˆçº¦ç›¸äº’çŸ›ç›¾ï¼Œé‚£ä¹ˆè¢«æ’åœ¨ç¬¬äºŒä½çš„åˆçº¦ä¼šè¢«æ‹’ç»è€Œä¸æˆä¸ºåŒºå—çš„ä¸€éƒ¨åˆ†ã€‚

è¿™äº›åŒºå—è¡Œç¨‹ä¸€ä¸ªçº¿æ€§åºåˆ—ï¼ŒåŒºå—é“¾è¿™ä¸ªè¯å°±æºäºæ­¤ã€‚

ä½œä¸ºâ€œé¡ºåºæŒ‘é€‰æœºåˆ¶â€ï¼ˆå³æ‰€è°“çš„â€œæŒ–çŸ¿â€ï¼‰çš„ä¸€éƒ¨åˆ†ï¼ŒåŒºå—å¯èƒ½ä¼šè¢«å›æ»šï¼Œä½†è¿™ç§æƒ…å†µåªä¼šå‘ç”Ÿåœ¨é“¾çš„æœ«æ¢¢ã€‚è¶Šå¤šçš„åŒºå—è¢«åŠ åˆ°é¡¶éƒ¨ï¼ŒåŸæ¥çš„åŒºå—å°±è¶Šä¸å®¹æ˜“è¢«å›æ»šã€‚

### ä»¥å¤ªåŠè™šæ‹Ÿæœº ###

#### æ¦‚è§ˆ ####

ä»¥å¤ªåŠè™šæ‹Ÿæœºï¼ˆEVMï¼‰æ˜¯æ™ºèƒ½åˆçº¦çš„è¿è¡Œæ—¶ã€‚å®ƒä¸åªæ˜¯ä¸€ä¸ªæ²™ç›’ï¼Œè€Œä¸”è¢«å®Œå…¨éš”ç¦»äº†ï¼Œä¹Ÿå°±æ˜¯è¯´EVM ä¸èƒ½è®¿é—®ç½‘ç»œã€æ–‡ä»¶ç³»ç»Ÿå’Œå…¶ä»–è¿›ç¨‹ï¼ˆFabric çš„æ™ºèƒ½åˆçº¦ç†è®ºä¸Šæ²¡æœ‰è¿™ä¸ªé™åˆ¶ï¼‰ã€‚æ™ºèƒ½åˆçº¦ç”šè‡³å—é™è®¿é—®å…¶ä»–æ™ºèƒ½åˆçº¦ã€‚

#### è´¦æˆ· ####

ä»¥å¤ªåŠä¸­æœ‰ä¸¤ç±»è´¦æˆ·å…±äº«åŒæ ·çš„åœ°å€ç©ºé—´ï¼šç”±å…¬ç§é’¥å¯¹ï¼ˆå³äººç±»ï¼‰æ§åˆ¶çš„å¤–éƒ¨è´¦æˆ·ä»¥åŠä¸åˆçº¦ä¸€åŒå­˜å‚¨çš„ä»£ç æ§åˆ¶çš„åˆçº¦è´¦æˆ·ã€‚

å¤–éƒ¨è´¦æˆ·çš„åœ°å€æ˜¯åˆå…¬é’¥æ§åˆ¶çš„ï¼Œè€Œåˆçº¦çš„åœ°å€åˆ™æ˜¯åœ¨åˆçº¦åˆ›å»ºæ—¶å†³å®šçš„ï¼ˆç”±åˆ›å»ºè€…çš„åœ°å€å’Œä»å“ªä¸ªåœ°å€é‡Œå‘å‡ºçš„äº‹åŠ¡æ•°ï¼ˆå³ nonceï¼‰è¡ç”Ÿã€‚ï¼‰ã€‚

ä¸è€ƒè™‘è´¦æˆ·æ˜¯ä¸æ˜¯å­˜å‚¨æœ‰ä»£ç ï¼Œä¸¤ç§ç±»å‹è¢« EVM å¹³ç­‰å¯¹å¾…ã€‚

æ¯ä¸€ä¸ªè´¦æˆ·æœ‰æŒä¹…åŒ–çš„çš„é”®å€¼å­˜å‚¨å« storageï¼Œæ˜ å°„256ä½çš„å­—åˆ°256ä½çš„å­—ã€‚

é™¤æ­¤ä¹‹å¤–ï¼Œæ¯ä¸ªè´¦æˆ·éƒ½æœ‰ä¸€ä¸ªä»¥å¤ªå¸ï¼ˆä»¥ wei ä¸ºå•ä½ï¼‰ä½™é¢ï¼Œå¯ä»¥é€šè¿‡å‘é€å«æœ‰ä»¥å¤ªå¸çš„äº‹åŠ¡è¿›è¡Œä¿®æ”¹ã€‚


#### äº‹åŠ¡ ####

äº‹åŠ¡æ˜¯ä»ä¸€ä¸ªè´¦æˆ·å‘é€å¾€å¦ä¸€ä¸ªè´¦æˆ·ï¼ˆå¦ä¸€ä¸ªè´¦æˆ·å¯ä»¥æ˜¯åŒä¸€ä¸ªè´¦æˆ·æˆ–è€…ç‰¹æ®Šçš„é›¶è´¦æˆ·ï¼‰çš„æ¶ˆæ¯ã€‚å®ƒå¯ä»¥åŒ…å«äºŒè¿›åˆ¶æ•°æ®ï¼ˆå®ƒçš„è½½è·ï¼‰å’Œä»¥å¤ªå¸ã€‚

å¦‚æœç›®æ ‡è´¦æˆ·åŒ…å«ä»£ç ï¼Œé‚£ä¹ˆä»£ç å¯ä»¥è¢«æ‰§è¡Œï¼Œè€Œè½½è·åˆ™å¯ä»¥è¢«å½“åšè¾“å…¥æ•°æ®ï¼ˆæŒ‰ï¼Œç­‰åŒäº message callï¼‰ã€‚

å¦‚æœç›®æ ‡è´¦æˆ·æ˜¯ä¸€ä¸ªé›¶è´¦æˆ·ï¼ˆè´¦æˆ·åœ°å€æ˜¯0ï¼‰ï¼Œäº‹åŠ¡ä¼šäº§ç”Ÿä¸€ä¸ªæ–°åˆçº¦ï¼ˆè¿™ä¹Ÿæ˜¯ç¼–ç¨‹å¼äº§ç”Ÿæ–°åˆçº¦çš„æ–¹æ³•ï¼‰ã€‚åˆ›é€ åˆçº¦çš„æ—¶å€™ï¼Œæˆ‘ä»¬åœ¨äº‹åŠ¡é‡Œå‘é€çš„è½½è·å®é™…ä¸Šå¹¶ä¸æ˜¯åˆçº¦æœ¬èº«ï¼Œè€Œæ˜¯èƒ½å¤Ÿäº§ç”Ÿåˆçº¦çš„ä»£ç ã€‚

æ³¨æ„ï¼Œè¿™ä¸ªé›¶è´¦æˆ·æŒ‡çš„æ˜¯ä¸€ä¸ª transaction é‡Œé¢çš„ to çš„é›¶å€¼ï¼š
```
transaction = {
  nonce: '0x0', 
  gasLimit: '0x6acfc0', // 7000000
  gasPrice: '0x4a817c800', // 20000000000
  to: '0x0',
  value: '0x0',
  data: '0xfffff'
};
```
å…·ä½“æ€è¾¨å†…å®¹è§[æ­¤][1]ã€‚


#### Gas ####

ä¸€åˆ›å»ºå®Œæˆï¼Œæ¯ä¸ªäº‹åŠ¡æ€»è¦æ”¶å–ä¸€å®šé‡çš„ gasï¼Œç”¨æ„æ˜¯ä¸ºäº†é™åˆ¶æ‰§è¡Œäº‹åŠ¡æ‰€éœ€çš„å·¥ä½œé‡ï¼Œå¹¶ä¸ºæ‰§è¡Œäº‹åŠ¡ä»˜è´¹ã€‚å½“ EVM æ‰§è¡Œäº‹åŠ¡çš„æ—¶å€™ï¼Œgas æ ¹æ®ç‰¹å®šè§„åˆ™è¢«é€æ¸æ¶ˆè€—ã€‚

gas åŠ ä¸ªæ˜¯ç”±äº‹åŠ¡åˆ›å»ºè€…è®¾ç«‹çš„ï¼Œå‘å‡ºï¼ˆäº‹åŠ¡çš„ï¼‰è´¦æˆ·å¿…é¡»ä»˜å‡º`gas_price * gas`çš„é¢„ä»˜æ¬¾ã€‚å¦‚æœæ‰§è¡Œä¹‹åè¿˜æœ‰ gas å‰©ä½™ï¼Œå®ƒä¼šè¢«åŸè·¯é€€å›ã€‚

å¦‚æœ gas åœ¨ä»»ä½•æ—¶åˆ»è¢«ç”¨å°½ï¼Œä¸€ä¸ª out-of-gas å¼‚å¸¸ä¼šè¢«è§¦å‘ï¼Œå› æ­¤ä¼šåè½¬å½“å‰è°ƒç”¨å¸§å¯¹çŠ¶æ€çš„æ‰€æœ‰ä¿®æ”¹ã€‚

#### Storageï¼Œ Memory å’Œ Stack ####

æ¯ä¸ªè´¦æˆ·éƒ½æœ‰ä¸€ä¸ª**æŒä¹…åŒ–çš„å†…å­˜åŒºåŸŸ**ï¼Œè¢«ç§°ä½œ`storage`ã€‚Storage æ˜¯ä¸€ä¸ªé”®å€¼å­˜å‚¨ï¼Œå®ƒæŠŠ256ä½çš„å­—æ˜ å°„åˆ°256ä½çš„å­—ã€‚ä¸å¯èƒ½åœ¨ä¸€ä¸ªåˆçº¦å†…éƒ¨æšä¸¾ storageï¼Œè€Œè¯»storageä¹Ÿæ˜¯ç›¸å¯¹æ˜‚è´µçš„ï¼Œ ä¿®æ”¹ storage æ›´æ˜¯æ˜‚è´µã€‚ä¸€ä¸ªåˆçº¦ä¸èƒ½è¯»å’Œå†™å®ƒè‡ªå·±çš„ storage ä¸­è‡ªå·±æ‹¥æœ‰çš„éƒ¨åˆ†ä¹‹å¤–çš„ä¸œè¥¿ã€‚

ç¬¬äºŒä¸ªå†…å­˜åŒºåŸŸå«åš`memory`ï¼Œå®ƒè®©åˆçº¦ä¸ºæ¯ä¸€ä¸ªæ¶ˆæ¯è°ƒç”¨è·å¾—äº†ä¸€ä¸ªå…¨æ–°æ¸…ç†è¿‡çš„å®ä¾‹ã€‚memory æ˜¯çº¿æ€§çš„ï¼Œå¯ä»¥åœ¨å­—èŠ‚çº§åˆ«è¢«å¯»å€ï¼Œä½†è¯»è¢«é™åˆ¶åˆ°256ä½å®½ï¼Œå†™å¾—å¯ä»¥å†™8ä½åˆ°256ä½å®½ã€‚memory è¢«å­—ï¼ˆ256ä½ï¼‰å±•å¼€ï¼Œå½“è®¿é—®ï¼ˆä¸ç®¡æ˜¯è¯»æˆ–è€…å†™ï¼‰ä¸€ä¸ªä¹‹å‰æ²¡æœ‰æ¥è§¦è¿‡çš„å†…å­˜å­—ï¼ˆå³ï¼Œä¸€ä¸ªå­—å†…çš„ä»»ä½•åç§»ï¼‰ã€‚åœ¨å±•å¼€çš„æ—¶å€™ï¼Œgas çš„èŠ±è´¹ä¹Ÿå¿…é¡»è¦ä¹‹ä¸°å¯Œã€‚memory å¢é•¿çš„è¶Šå¤§ï¼Œè¶Šæ˜‚è´µï¼ˆå› ä¸ºå®ƒæ˜¯å¹³æ–¹çº§æ‰©å®¹çš„ï¼‰ã€‚

EVM ä¸æ˜¯ä¸ªå¯„å­˜å™¨æœºå™¨è€Œæ˜¯ä¸ªæ ˆæœºå™¨ï¼Œæ‰€ä»¥æ‰€æœ‰çš„è®¡ç®—éƒ½åœ¨ä¸€ä¸ªå« stack çš„åŒºåŸŸä¸Šæ‰§è¡Œã€‚æ ˆæœ‰ä¸€ä¸ª1024ä¸ªå…ƒç´ çš„æœ€å¤§å°ºå¯¸ï¼Œå¹¶ä¸”åŒ…å«256ä½çš„å­—ã€‚åªå…è®¸é€šè¿‡è¿™ç§æ–¹å¼ä»æ ˆé¡¶è®¿é—®å…ƒç´ ï¼šå¯ä»¥æ‹·è´æœ€é¡¶ä¸Šçš„16ä¸ªå…ƒç´ ä¸­çš„ä¸€ä¸ªæˆ–è€…æŠŠæœ€é¡¶ä¸Šçš„åå…­ä¸ªå…ƒç´ ä¸­çš„ä¸€ä¸ªä¸å…¶ä¸‹çš„å…ƒç´ ç¿»è½¬ã€‚æŒ‰ï¼šè¿™ä¹Ÿå°±æ˜¯ stack é‡Œçš„å±€éƒ¨å˜é‡è¡¨åªå…è®¸æœ‰16ä¸ªå˜é‡çš„åŸå› ã€‚çœ‹èµ·æ¥æ‰€æœ‰çš„ EVM è¯­è¨€ï¼ŒåŒ…æ‹¬ä½†ä¸é™äº Solidityï¼Œéƒ½å—è¿™ä¸ªé™åˆ¶å½±å“ã€‚å…¶ä»–æ“ä½œåˆ™åªèƒ½ä»æ ˆä¸Šå–æœ€é¡¶ä¸Šçš„ä¸¤ä¸ªï¼ˆæˆ–ä¸€æˆ–æ›´å¤šï¼Œå–å†³äºå…·ä½“æ“ä½œï¼‰å…ƒç´ å¹¶å°†ç»“æœæ¨ä¸Šæ ˆã€‚å½“ç„¶å¯èƒ½æŠŠæ ˆä¸Šçš„å…ƒç´ ç§»åŠ¨åˆ° storage å’Œ memoryï¼Œä½†ä¸å¯èƒ½åœ¨ä¸ç§»é™¤æ ˆé¡¶å…ƒç´ çš„å‰æä¸‹ï¼Œè®¿é—®æ ˆä¸Šæ›´æ·±çš„ä»»æ„å…ƒç´ ã€‚

#### æŒ‡ä»¤é›† ####

EVM çš„æŒ‡ä»¤é›†è¢«ä¿æŒæå°è§„æ¨¡ï¼Œä»¥é˜²é”™è¯¯çš„å®ç°å¼•å‘å…±è¯†é—®é¢˜ã€‚æ‰€æœ‰çš„æŒ‡ä»¤éƒ½æ“ä½œåœ¨åŸºæœ¬æ•°æ®ç±»å‹ï¼Œ256ä½çš„å­—ä¸Šã€‚å¸¸è§çš„ç®—æ•°ã€ä½ã€é€»è¾‘å’Œæ¯”è¾ƒæ“ä½œç¬¦æ˜¯ç°æˆçš„ã€‚æ¡ä»¶å’Œéæ¡ä»¶è·³è½¬æ˜¯å¯è¡Œçš„ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œåˆçº¦èƒ½å¤Ÿè®¿é—®å½“å‰åŒºå—çš„ç›¸å…³å±æ€§æ¯”å¦‚æ•°å­—å’Œæ—¶é—´æˆ³ã€‚

#### æ¶ˆæ¯è°ƒç”¨ ####

åˆçº¦å¯ä»¥è°ƒç”¨å…¶ä»–åˆçº¦ï¼Œæˆ–è€…é€šè¿‡æ¶ˆæ¯è°ƒç”¨çš„æ–¹å¼å‘é€ä»¥å¤ªå¸åˆ°éåˆçº¦è´¦æˆ·ã€‚æ¶ˆæ¯è°ƒç”¨ç±»ä¼¼äº‹åŠ¡ï¼Œæ‰€ä»¥å®ƒæœ‰æºã€ç›®æ ‡ã€æ•°æ®è½½è·ã€ä»¥å¤ªå¸ã€gas å’Œè¿”å›å€¼ã€‚äº‹å®ä¸Šï¼Œæ‰€æœ‰çš„äº‹åŠ¡éƒ½åŒ…å«ä¸€ä¸ª**é¡¶çº§æ¶ˆæ¯è°ƒç”¨**ï¼ˆæŒ‰ï¼šå¯ä»¥ç†è§£ä¸ºå…ƒæ¶ˆæ¯è°ƒç”¨ï¼‰ï¼Œå®ƒå¯ä»¥åˆ›é€ æ›´å¤šçš„æ¶ˆæ¯è°ƒç”¨ã€‚

ä¸€ä¸ªåˆçº¦å†³å®šæœ‰å¤šå°‘å®ƒçš„å‰©ä½™ gas éœ€è¦è¢«ä¼´éšå†…éƒ¨æ¶ˆæ¯è°ƒç”¨å‘é€ï¼Œæœ‰å¤šå°‘å®ƒæƒ³è¦ä¿ç•™ã€‚å¦‚æœä¸€ä¸ª out-of-gas å¼‚å¸¸åœ¨å†…éƒ¨è°ƒç”¨å‘ç”Ÿäº†ï¼ˆæˆ–è€…ä»»ä½•å…¶ä»–å¼‚å¸¸ï¼‰ï¼Œè¿™ä»¶äº‹ä¼šä»¥ä¸€ä¸ªè¢«æ”¾åœ¨æ ˆä¸Šçš„é”™è¯¯å€¼ä½œä¸ºä¿¡å·ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œåªæœ‰ä¼´éšç€è¿™ä¸ªè°ƒç”¨çš„ gas è¢«ç”¨å°½äº†ï¼ˆæŒ‰ï¼šå…¶å®ƒçš„ gas æ²¡æœ‰è¢«ç”¨å°½ï¼‰ã€‚åœ¨ Solidity ä¸­ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè°ƒç”¨æ–¹åˆçº¦å¼•å‘ä¸€ä¸ªæ‰‹åŠ¨å¼‚å¸¸ï¼ˆæŒ‰ï¼šä¸‹é¢ä¼ ä¸Šæ¥çš„æ˜¯é”™è¯¯ç ï¼Œåœ¨è¿™é‡Œæ‰ raise å¼‚å¸¸ï¼‰ï¼Œæ‰€ä»¥å¼‚å¸¸çŠ¶å†µå°±åœ¨è°ƒç”¨æ ˆä¸Šè¢«å†’æ³¡ä¸Šå»äº†ã€‚

æ­£å¦‚å·²ç»æåˆ°çš„ï¼Œè¢«è°ƒç”¨çš„åˆçº¦ï¼ˆå®ƒå¯ä»¥æ˜¯è°ƒç”¨è€…æœ¬èº«ï¼‰ä¼šæ”¶åˆ°ä¸€ä¸ªå…¨æ–°çš„è¢«æ¸…ç†è¿‡çš„å†…å­˜å®ä¾‹ï¼Œå¹¶ä¸”å¯ä»¥è®¿é—®è°ƒç”¨è½½è·-å®ƒä¼šåœ¨ä¸€ä¸ªå•ç‹¬çš„è¢«ç§°ä½œ`alldata` çš„åŒºåŸŸé‡Œè¢«æä¾›ã€‚å½“å®ƒæ‰§è¡Œå®Œæˆä»¥åï¼Œå®ƒå¯ä»¥è¿”å›æ•°æ®ï¼Œæ•°æ®ä¼šè¢«å­˜è´®åœ¨è°ƒç”¨è€…çš„é¢„åˆ†é…å†…å­˜é‡Œçš„æŸä¸€ä¸ªéƒ¨åˆ†ã€‚æŒ‰ï¼šç±»ä¼¼ä¼ ç»Ÿè°ƒç”¨æ ˆçš„è¿”å›å€¼å¯„å­˜å™¨ã€‚è°ƒç”¨è¢«é™åˆ¶åœ¨ä¸€ä¸ª1024çš„æ·±åº¦ä¸Šï¼Œè¿™æ„å‘³ç€å¯¹æ›´å¤æ‚çš„æ“ä½œï¼Œå¾ªç¯åº”è¯¥ä¼˜äºé€’å½’ã€‚

#### Delegatecallï¼ˆå§”æ‰˜è°ƒç”¨ï¼‰/Callcodeï¼ˆè°ƒç”¨ä»£ç ï¼‰ å’Œ Libraries(åº“) ####

å­˜åœ¨æ¶ˆæ¯è°ƒç”¨çš„ä¸€ä¸ªç‰¹æ®Šå˜ç§ï¼Œåä¸º delegatecallï¼Œå®ƒå’Œä¸€ä¸ªæ¶ˆæ¯è°ƒç”¨å®Œå…¨ä¸€æ ·ï¼Œé™¤äº†ç›®æ ‡åœ°å€çš„ä»£ç æ˜¯åœ¨è°ƒç”¨æ–¹åˆçº¦çš„ä¸Šä¸‹æ–‡é‡Œæ‰§è¡Œï¼ˆæŒ‰ï¼šæ„å³ï¼Œä¸æ˜¯åœ¨è¢«è°ƒç”¨åˆçº¦ä¸Šä¸‹æ–‡é‡Œæ‰§è¡Œï¼‰ï¼Œå¹¶ä¸” msg.sender å’Œ msg.value æ²¡æœ‰æ”¹å˜å®ƒä»¬çš„å€¼ï¼ˆæŒ‰ï¼šå’Œè°ƒç”¨æ–¹åˆçº¦é‡Œçš„å€¼ä¸€æ ·ï¼‰ã€‚

è¿™æ„å‘³ç€ä¸€ä¸ªåˆçº¦å¯ä»¥åœ¨è¿è¡Œæ—¶åŠ¨æ€åœ°ä»å…¶ä»–åœ°å€æå–ä»£ç ã€‚å­˜å‚¨ã€å½“å‰åœ°å€å’Œä½™é¢ï¼Œä¾æ—§æŒ‡å‘è°ƒç”¨æ–¹åˆçº¦ï¼Œåªæœ‰ä»£ç æ˜¯ä»è¢«è°ƒç”¨æ–¹åˆçº¦é‡Œæ‹¿æ¥çš„ã€‚è¿™æ„å‘³ç€åœ¨ Solidity ä¸­å®ç°åº“è¿™ä¸€ç‰¹å¾æ˜¯å¯èƒ½çš„ï¼šå¯å¤ç”¨çš„åº“ä»£ç å¯ä»¥åº”ç”¨åˆ°ä¸€ä¸ªåˆçº¦çš„å­˜å‚¨é‡Œï¼Œæ„å³ï¼Œå¯ä»¥ï¼ˆé€šè¿‡å¤ç”¨åº“ï¼‰å®ç°å¤æ‚çš„æ•°æ®ç»“æ„ã€‚

#### æ—¥å¿— ####

å¯ä»¥åœ¨ä¸“é—¨ç´¢å¼•è¿‡çš„æ•°æ®ç»“æ„é‡Œå­˜å‚¨æ•°æ®ï¼Œè¿™æŠŠæ‰€æœ‰çš„æ–¹æ³•éƒ½æ˜ å°„åˆ°äº†åŒºå—çº§åˆ«ï¼ˆæŒ‰ï¼šå³åœ¨åŒºå—çº§åˆ«æ¥æ€è€ƒæ€ä¹ˆè§£å†³ç›¸å…³é—®é¢˜ï¼‰ã€‚è¢«ç§°ä½œlogï¼ˆæ—¥å¿—ï¼‰çš„ç‰¹å¾è¢« Solidity ç”¨æ¥å®ç° eventsï¼ˆäº‹ä»¶ï¼‰ã€‚åˆçº¦ä¸èƒ½åœ¨æ—¥å¿—è¢«åˆ›å»ºåè®¿é—®å®ƒä»¬ï¼ˆå³ log è¢«åˆ›å»ºåå°±ä¸èƒ½åœ¨å†…éƒ¨ä»ä»»ä½•ä¸€ä¸ªåœ°æ–¹è¢«è¯»å–äº†ï¼‰ã€‚ä½†å®ƒä»¬å¯ä»¥ä»é“¾å¤–è¢«è¯»å–ã€‚ç”±äºæœ‰ä¸€éƒ¨åˆ† log æ•°æ®è¢«å­˜å‚¨åœ¨å¸ƒéš†è¿‡æ»¤å™¨é‡Œï¼Œæ‰€ä»¥å¯ä»¥é€šè¿‡æœ‰æ•ˆç‡å’ŒåŠ å¯†å®‰å…¨çš„æ–¹æ³•æ¥æœç´¢å…¶ä¸­æ•°æ®ï¼Œæ‰€ä»¥ç½‘ç»œå¯¹ç­‰èŠ‚ç‚¹ï¼ˆè½»å®¢æˆ·ç«¯ï¼‰ä¸éœ€è¦ä¸‹è½½å®Œæ•´çš„åŒºå—å°±å¯ä»¥å‘è¡Œè¿™äº›æ—¥å¿—ã€‚

#### åˆ›å»º ####

åˆçº¦ç”šè‡³å¯ä»¥ä½¿ç”¨ç‰¹æ®Šçš„opcodeï¼ˆæ“ä½œç ï¼‰åˆ›å»ºå…¶ä»–åˆçº¦ï¼ˆå®ƒä»¬å¹¶ä¸åªæ˜¯ç®€å•åœ°è°ƒç”¨é›¶åˆçº¦åœ°å€ï¼Œè¿™å·²ç»æ˜¯ç¬¬äºŒç§å·²çŸ¥çš„åˆ›å»ºåˆçº¦çš„æ–¹æ³•äº†ï¼‰ã€‚**åˆ›å»ºè°ƒç”¨**å’Œæ™®é€šæ¶ˆæ¯è°ƒç”¨çš„å”¯ä¸€å·®åˆ«æ˜¯è½½è·æ•°æ®è¢«æ‰§è¡Œäº†ï¼Œè€Œç»“æœè¢«å½“åšä»£ç å­˜å‚¨ã€‚è°ƒç”¨è€…/åˆ›å»ºè€…åœ¨æ ˆä¸Šæ¥æ”¶åˆ°æ–°åˆçº¦çš„åœ°å€ã€‚

#### è‡ªæ¯ ####

ä»£ç è¢«ä»åŒºå—é“¾ä¸Šç§»å‡ºçš„å”¯ä¸€å¯èƒ½æ€§æ˜¯å½“ä¸€ä¸ªåˆçº¦æ‰§è¡Œ`selfdestruct`æ“ä½œçš„æ—¶å€™ã€‚åœ°å€ä¸­å­˜å‚¨çš„å‰©ä½™ä»¥å¤ªå¸ä¼šè¢«å‘é€ç»™ä¸€ä¸ªè®¾å®šå¥½çš„ç›®æ ‡ï¼ˆè´¦æˆ·ï¼‰ï¼Œæ¥ç€çŠ¶æ€ï¼ˆæ•°æ®åº“çš„å­˜å‚¨ï¼‰ä¸­çš„å­˜å‚¨å’ŒçŠ¶æ€å°†è¢«ç§»é™¤ã€‚

**å³ä½¿ä¸€ä¸ªåˆçº¦çš„ä»£ç ä¸­ä¸åŒ…å«ä¸€ä¸ªåˆ°`selfdestruct`çš„è°ƒç”¨ï¼Œå®ƒä»ç„¶å¯ä»¥é€šè¿‡`delegatecall`å’Œ`callcode`æ¥æ‰§è¡Œé‚£ä¸ªæ“ä½œã€‚**

**å¯¹äºè€ä»¥å¤ªåŠèŠ‚ç‚¹è€Œè¨€ï¼Œè¿™ä¸ªçŠç‘šå¹¶ä¸ä¸€å®šæ˜¯ç‰©ç†åˆ é™¤ï¼Œä¹Ÿå¯ä»¥æ˜¯è½¯åˆ é™¤**

**å½“å‰å¤–éƒ¨è´¦æˆ·ï¼ˆå³ä¸ªäººçš„ accountï¼‰æ˜¯ä¸èƒ½ä» state ä¸­ç§»é™¤æ‰çš„ã€‚æŒ‰ï¼šå³åˆçº¦è´¦æˆ·å¯ä»¥è¢«ç§»é™¤**

## Solidityä¸¾ä¾‹ ##

### é€‰ä¸¾ ###

æ¥ä¸‹æ¥çš„åˆçº¦å°±éå¸¸å¤æ‚äº†ï¼Œå®ƒæ˜¾ç¤ºäº† Solidity çš„ä¸€å¤§å †ä¼˜ç‚¹ã€‚å®ƒå®ç°äº†ä¸€ä¸ªæŠ•ç¥¨åˆçº¦ã€‚å½“ç„¶ï¼Œç”µå­æŠ•ç¥¨çš„ä¸»è¦é—®é¢˜æ˜¯å¦‚ä½•åˆ†é…æŠ•ç¥¨æƒç»™æ­£ç¡®çš„äººç¾¤å’Œå¦‚ä½•é˜»æ­¢æ“çºµé€‰ä¸¾ã€‚æˆ‘ä»¬ä¸ä¼šåœ¨è¿™é‡Œè§£å†³æ‰€æœ‰çš„é—®é¢˜ï¼Œä½†æœ€èµ·ç æˆ‘ä»¬ä¼šæ˜¾å¼è¢«ä»£ç†çš„é€‰ä¸¾å¦‚ä½•å®Œæˆï¼Œå¹¶ä¸”è®¡ç¥¨æ˜¯è‡ªåŠ¨å’ŒåŒæ—¶å®Œå…¨é€æ˜çš„ã€‚

å¥¥å¦™å°±æ˜¯æ¯ä¸€ä¸ªballotï¼ˆæŠ•ç¥¨ï¼‰ä¸€ä¸ªåˆçº¦ï¼Œä¸ºæ¯ä¸ªé€‰é¡¹æä¾›ä¸€ä¸ªçŸ­åå­—ã€‚ç„¶ååˆçº¦çš„åˆ›å»ºè€…ä½œä¸ºä¸»å¸­ä¼šæŠŠæŠ•ç¥¨æƒå•ç‹¬æˆäºˆæ¯ä¸ªåœ°å€ã€‚

åœ°å€åé¢çš„äººå¯ä»¥é€‰æ‹©è¦ä¹ˆè‡ªå·±æŠ•ç¥¨ï¼Œè¦ä¹ˆæŠŠä»–ä»¬çš„æŠ•ç¥¨æƒdelegateï¼ˆå§”æ‰˜ï¼‰ä¸€ä¸ªä»–ä»¬ä¿¡ä»»çš„äººã€‚

åœ¨é€‰ä¸¾ç»“æŸçš„æ—¶å€™ï¼Œ`winningProposal()`ä¼šè¿”å›æœ€å¤§æŠ•ç¥¨æ•°çš„å»ºè®®ã€‚

```javascript
pragma solidity ^0.4.16;

/// @title Voting with delegation.
contract Ballot {
    // This declares a new complex type which will
    // be used for variables later.
    // It will represent a single voter.
    struct Voter {
        uint weight; // weight is accumulated by delegation
        bool voted;  // if true, that person already voted
        address delegate; // person delegated to
        uint vote;   // index of the voted proposal
    }

    // This is a type for a single proposal.
    struct Proposal {
        bytes32 name;   // short name (up to 32 bytes)
        uint voteCount; // number of accumulated votes
    }

    address public chairperson;

    // This declares a state variable that
    // stores a `Voter` struct for each possible address.
    mapping(address => Voter) public voters;

    // A dynamically-sized array of `Proposal` structs.
    Proposal[] public proposals;

    /// Create a new ballot to choose one of `proposalNames`.
    function Ballot(bytes32[] proposalNames) public {
        chairperson = msg.sender;
        // ä¸»å¸­æœ‰æŠ•ç¥¨æƒ
        voters[chairperson].weight = 1;

        // For each of the provided proposal names,
        // create a new proposal object and add it
        // to the end of the array.
        for (uint i = 0; i < proposalNames.length; i++) {
            // `Proposal({...})` creates a temporary
            // Proposal object and `proposals.push(...)`
            // appends it to the end of `proposals`.
            proposals.push(Proposal({
                name: proposalNames[i],
                voteCount: 0
            }));
        }
    }

    // Give `voter` the right to vote on this ballot.
    // May only be called by `chairperson`.
    function giveRightToVote(address voter) public {
        // If the argument of `require` evaluates to `false`,
        // it terminates and reverts all changes to
        // the state and to Ether balances. It is often
        // a good idea to use this if functions are
        // called incorrectly. But watch out, this
        // will currently also consume all provided gas
        // (this is planned to change in the future).
        // require ç±»ä¼¼æ–­è¨€ï¼Œä¼šåè½¬æ‰€æœ‰çš„åŒºå—é“¾ stateï¼Œä½†è¿˜æ˜¯ä¼šæ¶ˆè€— gasï¼ˆè¿™ç‚¹æœªæ¥ä¼šè¢«ä¿®æ”¹ï¼‰ï¼Œè¿™æ¯” return å¥½å—ï¼Ÿ
        require((msg.sender == chairperson) && !voters[voter].voted && (voters[voter].weight == 0));
        // æŸä¸ªæŠ•ç¥¨è€…åœ°å€è·å¾—äº†æŠ•ç¥¨æƒ
        voters[voter].weight = 1;
    }

    /// Delegate your vote to the voter `to`.
    function delegate(address to) public {
        // assigns reference
        // ç¬¬ä¸€ä¸ªå‡ºç°çš„æ˜¾å¼ storageï¼Œè¿™è¯æ˜è¯»æˆå‘˜å˜é‡èµ‹ç»™å±€éƒ¨å˜é‡æ€»æ˜¯è¦æ±‚ storage çš„
        Voter storage sender = voters[msg.sender];
        require(!sender.voted);

        // Self-delegation is not allowed.
        require(to != msg.sender);

        // Forward the delegation as long as
        // `to` also delegated.
        // In general, such loops are very dangerous,
        // because if they run too long, they might
        // need more gas than is available in a block.
        // In this case, the delegation will not be executed,
        // but in other situations, such loops might
        // cause a contract to get "stuck" completely.
        // è¿™é‡Œä½¿ç”¨äº†ä¸€ä¸ªå¯ä»¥æ¯”è¾ƒé›¶åœ°å€çš„ä¾‹å­ï¼Œè¯æ˜ä¸å¯ä»¥ç›´æ¥ != 0æ¥æ¯”è¾ƒ
        // åœ¨ç°å®ä¸­è¿™æ ·çš„å¾ªç¯å¯èƒ½å¾ˆè€— gas
        while (voters[to].delegate != address(0)) {
            to = voters[to].delegate;

            // We found a loop in the delegation, not allowed.
            // å†…ç½® required æ–­è¨€
            require(to != msg.sender);
        }

        // Since `sender` is a reference, this
        // modifies `voters[msg.sender].voted`
        // æŠŠè¢«å§”æ‰˜è€…çš„æ—§å€¼ä½œåºŸæ‰
        sender.voted = true;
        sender.delegate = to;
        Voter storage delegate = voters[to];
        if (delegate.voted) {
            // If the delegate already voted,
            // directly add to the number of votes
            proposals[delegate.vote].voteCount += sender.weight;
        } else {
            // If the delegate did not vote yet,
            // add to her weight.
            delegate.weight += sender.weight;
        }
    }

    // æ¯ä¸€ä¸ªåˆçº¦éƒ½æ˜¯
    /// Give your vote (including votes delegated to you)
    /// to proposal `proposals[proposal].name`.
    function vote(uint proposal) public {
        Voter storage sender = voters[msg.sender];
        require(!sender.voted);
        sender.voted = true;
        sender.vote = proposal;

        // If `proposal` is out of the range of the array,
        // this will throw automatically and revert all
        // changes.
        proposals[proposal].voteCount += sender.weight;
    }

    /// @dev Computes the winning proposal taking all
    /// previous votes into account.
    function winningProposal() public view
            returns (uint winningProposal)
    {
        // solidity çš„ dummy æ•°å€¼å¯¹è±¡å°±æ˜¯è¿™æ ·å†™çš„äº†
        uint winningVoteCount = 0;
        // æ³¨æ„ï¼Œè¿™ä¸ª proposals æ˜¯æ•°ç»„ï¼Œwinner å…¶å®åªæ˜¯è¿™ä¸ªæ•°ç»„çš„ä¸€ä¸ªç´¢å¼•
        for (uint p = 0; p < proposals.length; p++) {
            if (proposals[p].voteCount > winningVoteCount) {
                winningVoteCount = proposals[p].voteCount;
                winningProposal = p;
            }
        }
    }

    // Calls winningProposal() function to get the index
    // of the winner contained in the proposals array and then
    // returns the name of the winner
    function winnerName() public view
            returns (bytes32 winnerName)
    {
        winnerName = proposals[winningProposal()].name;
    }
}
```

è¿™ä¸ªåˆçº¦å¯ä»¥æå‡çš„åœ°æ–¹ï¼Œå°±æ˜¯æ€æ ·æå‡äº‹åŠ¡çš„æ•ˆç‡ï¼Ÿ

### ç›²æ‹å– ###

#### ç®€å•æ‹å– ####

æ¥ä¸‹æ¥å‡ºç°çš„ç®€å•æ˜æ‹å–åˆçº¦çš„å¤§æ„æ˜¯æ¯ä¸ªäººéƒ½å¯ä»¥åœ¨æŠ•æ ‡æœŸå†…æŠŠæŠ•æ ‡æŠ•å‡ºå»ã€‚æŠ•æ ‡å·²ç»åŒ…å«äº†å‘é€é‡‘é’±/ä»¥å¤ªå¸ï¼Œä»¥æŠŠæŠ•æ ‡è€…å’ŒæŠ•æ ‡ç»‘å®šèµ·æ¥ã€‚å¦‚æœæœ€é«˜æŠ•æ ‡ä¸Šå‡äº†ï¼Œå‰ä¸€ä¸ªæœ€é«˜æŠ•æ ‡è€…ä¼šæ‹¿å›å¥¹çš„é’±ã€‚åœ¨æŠ•æ ‡å‘¨æœŸçš„æœ€åï¼Œåˆçº¦è¦è®©å—ç›Šäººæ‰‹åŠ¨è°ƒç”¨æ¥è·å¾—å®ƒçš„é’±ï¼Œåˆçº¦ä¸èƒ½æ¿€æ´»å®ƒè‡ªå·±ã€‚

```javascript
pragma solidity ^0.4.11;

contract SimpleAuction {
    // å–ä¸œè¥¿çš„äºº
    // Parameters of the auction. Times are either
    // absolute unix timestamps (seconds since 1970-01-01)
    // or time periods in seconds.
    address public beneficiary;
    // ç”¨æ•´æ•°æ¥è¡¨ç¤ºæ—¶é—´
    uint public auctionEnd;

    // å½“å‰æœ€é«˜æŠ•æ ‡è€…çš„åœ°å€
    // Current state of the auction.
    address public highestBidder;
    // æœ€é«˜çš„æŠ•æ ‡
    uint public highestBid;

    // å—è®¸å¯çš„ä¹‹å‰æŠ•æ ‡çš„é€€æ¬¾ï¼Œåœ¨è¿™é‡Œ withdrawal ç­‰äº refund äº†
    // Allowed withdrawals of previous bids
    mapping(address => uint) pendingReturns;

    // Set to true at the end, disallows any change
    bool ended;

    // Events that will be fired on changes.
    event HighestBidIncreased(address bidder, uint amount);
    event AuctionEnded(address winner, uint amount);
    
    // ä¸‰æ–œæ çš„æ˜¯æç¤ºç¬¦è¯„è®ºï¼Œå¯ä»¥æç¤ºç”¨æˆ·æ˜¯å¦ç¡®è®¤ä¸€ä¸ªäº‹åŠ¡
    // The following is a so-called natspec comment,
    // recognizable by the three slashes.
    // It will be shown when the user is asked to
    // confirm a transaction.

    /// Create a simple auction with `_biddingTime`
    /// seconds bidding time on behalf of the
    /// beneficiary address `_beneficiary`.
    function SimpleAuction(
        uint _biddingTime,
        address _beneficiary
    ) public {
        beneficiary = _beneficiary;
        // çœ‹æ¥ now ä¹Ÿæ˜¯ç§’æ•°çš„æ„æ€ã€‚æ¢è¨€ä¹‹ï¼Œæ²¡æœ‰æ¯«ç§’æ•°ã€‚
        auctionEnd = now + _biddingTime;
    }

    /// Bid on the auction with the value sent
    /// together with this transaction.
    /// The value will only be refunded if the
    /// auction is not won.
    // payable å°±æ˜¯æ‹¿æ¥ä¿®é¥° function çš„ï¼Œæ‰€ä»¥å®ƒæ˜¯ payble çš„ã€‚
    function bid() public payable {
        // No arguments are necessary, all
        // information is already part of
        // the transaction. The keyword payable
        // is required for the function to
        // be able to receive Ether.

        // Revert the call if the bidding
        // period is over.
        require(now <= auctionEnd);

        // If the bid is not higher, send the
        // money back.
        // è¿™ä¸ª payable çš„åˆçº¦ä¹Ÿå¯ä»¥è¢«æ–­è¨€æ‰€ä¸­æ–­
        require(msg.value > highestBid);
        
        // æœ€é«˜æŠ•æ ‡è€…çš„åœ°å€çš„å¦ä¸€ç§æ¯”å¯¹æ–¹æ³•
        if (highestBidder != 0) {
            // Sending back the money by simply using
            // highestBidder.send(highestBid) is a security risk
            // because it could execute an untrusted contract.
            // It is always safer to let the recipients
            // withdraw their money themselves.
            pendingReturns[highestBidder] += highestBid;
        }
        highestBidder = msg.sender;
        highestBid = msg.value;
        HighestBidIncreased(msg.sender, msg.value);
        
        // è¿™ä¸ªæ–¹æ³•æ²¡æœ‰ä»»ä½•ç›´æ¥æ‘¸åˆçº¦ account çš„åœ°æ–¹ï¼Œä½†è¿™ä¸ªpayable æ–¹æ³•çš„å†…å®¹é‡Œå¤„å¤„å……æ»¡äº† msg.value
    }

    /// Withdraw a bid that was overbid.
    //  è¿™ä¸ªé€€æ¬¾å‡½æ•°æ˜¯è°æ¥è°ƒç”¨ ?
    function withdraw() public returns (bool) {
        uint amount = pendingReturns[msg.sender];
        if (amount > 0) {
            // It is important to set this to zero because the recipient
            // can call this function again as part of the receiving call
            // before `send` returns.
            pendingReturns[msg.sender] = 0;

            if (!msg.sender.send(amount)) {
                // No need to call throw here, just reset the amount owing
                pendingReturns[msg.sender] = amount;
                return false;
            }
        }
        return true;
    }

    /// End the auction and send the highest bid
    /// to the beneficiary.
    function auctionEnd() public {
        // It is a good guideline to structure functions that interact
        // with other contracts (i.e. they call functions or send Ether)
        // into three phases:
        // 1. checking conditions
        // 2. performing actions (potentially changing conditions)
        // 3. interacting with other contracts
        // If these phases are mixed up, the other contract could call
        // back into the current contract and modify the state or cause
        // effects (ether payout) to be performed multiple times.
        // If functions called internally include interaction with external
        // contracts, they also have to be considered interaction with
        // external contracts.

        // 1. Conditions
        require(now >= auctionEnd); // auction did not yet end
        require(!ended); // this function has already been called

        // 2. Effects
        ended = true;
        AuctionEnded(highestBidder, highestBid);

        // 3. Interaction
        beneficiary.transfer(highestBid);
    }
}
```

#### ç›²æ‹å– ####

ç›²æ‹å–çš„ä¼˜ç‚¹æ˜¯æ²¡æœ‰å‘ç€æ‹å–ç»ˆç‚¹çš„æ—¶é—´å‹åŠ›ã€‚

ç®€åŒ–ä¸€ä¸ªç›²æ‹å–æ¨¡å‹ã€‚ç”¨æˆ·å…ˆç”¨å¤´æ ‡å¿—çš„ hash æŠ•æ ‡ã€‚æŠ•æ ‡ç»“æŸåå¤§å®¶æ­ç¤ºå‡ºè‡ªå·±çš„æŠ•æ ‡å€¼ï¼ŒåŒæ—¶æ ¡éªŒ hash æ˜¯å¦ç›¸åŒä»¥åŠæ•°å€¼æ˜¯å¦æœ€é«˜ã€‚

ä¸ºäº†é˜²æ­¢æœ‰äº›äººæ‹å®Œä¸ç»™é’±ï¼Œè¿™ä¸ªåˆçº¦è¿˜è¿›ä¸€æ­¥è¦æ±‚å¤§å®¶æŠŠä»·å€¼å’ŒæŠ•æ ‡ä¸€èµ·å‘é€ï¼Œå‰è€…è‡ªç„¶æ˜¯æ˜æ–‡çš„ï¼Œè€Œåè€…æ˜¯åŠ å¯†çš„ã€‚ä¸ºäº†ä¸æš´éœ²éšç§ï¼Œåˆçº¦æ¥å—ä¸€åˆ‡é™„å¸¦çš„ä»·å€¼é«˜äºå½“å‰æœ€é«˜æŠ•æ ‡ä»·çš„æ–°æŠ•æ ‡è½¬è´¦ã€‚è¿™ä¹Ÿå°±æ„å‘³ç€ï¼Œåœ¨ä»·å€¼æ­ç¤ºç¯èŠ‚ï¼Œæœ‰äº›æŠ•æ ‡æ˜¯æ— æ•ˆçš„ä¸æˆç«‹çš„ã€‚æŠ•æ ‡è€…ç”šè‡³å¯ä»¥ç”¨ä¸€äº›é”™è¯¯çš„é«˜æŠ•æ ‡æˆ–è€…ä½æŠ•æ ‡æ¥è¿·æƒ‘æ•´ä¸ªç«äº‰ã€‚

```javascript
pragma solidity ^0.4.11;

contract BlindAuction {
    struct Bid {
        bytes32 blindedBid;
        // é”æ­»å­˜æ¬¾
        uint deposit;
    }

    address public beneficiary;
    uint public biddingEnd;
    uint public revealEnd;
    bool public ended;

    mapping(address => Bid[]) public bids;

    address public highestBidder;
    uint public highestBid;

    // Allowed withdrawals of previous bids
    mapping(address => uint) pendingReturns;

    event AuctionEnded(address winner, uint highestBid);

    /// Modifiers are a convenient way to validate inputs to
    /// functions. `onlyBefore` is applied to `bid` below:
    /// The new function body is the modifier's body where
    /// `_` is replaced by the old function body.
    // modifier æœ‰ç‚¹åƒè£…é¥°å™¨ï¼Œç»“åˆäº† requireï¼Œ_æŒ‡çš„å°±æ˜¯è¢«ä¿®é¥°æ–¹æ³•çš„ body
    modifier onlyBefore(uint _time) { require(now < _time); _; }
    modifier onlyAfter(uint _time) { require(now > _time); _; }

    function BlindAuction(
        uint _biddingTime,
        uint _revealTime,
        address _beneficiary
    ) public {
        beneficiary = _beneficiary;
        // åœ¨è¿™é‡Œç›´æ¥æ‹¿èµ·ç‚¹æ—¶é—´æˆ³æ¥ç”Ÿæˆæ¥ä¸‹æ¥çš„æ—¶é—´èŠ‚ç‚¹å°±è¡Œäº†
        biddingEnd = now + _biddingTime;
        revealEnd = biddingEnd + _revealTime;
    }

    // keccak å‡½æ•°æ˜¯ SHA-3å‡½æ•°çš„åˆ«åï¼Œè¢«ä»¥å¤ªåŠæ›´åè¿‡çš„å‡½æ•°ã€‚SHA-256å®é™…ä¸Šæ˜¯ SHA-2 çš„ä¸€ä¸ªå­ç±»å‹ï¼Œkeccak ç®—æ³•æ˜¯ä¸‹ä¸€ä»£çš„ SHA-3ç®—æ³•ï¼Œæ˜¯æœ€å¼ºçš„æ•£åˆ—ç®—æ³•ã€‚http://www.atool.org/hash.php
    // keccak æ˜¯ä¸ªæ¾æ•£å‚æ•°å‡½æ•°ï¼Œæ‰€æœ‰çš„è¾“å…¥éƒ½æ˜¯æ•£åˆ—çš„ç§å­ï¼Œä¼šè¢«å‡½æ•°ç›´æ¥æ‹¼æ¥èµ·æ¥ï¼Œç±»ä¼¼åˆ†æ®µç­¾åç›¸åŠ çš„æ€è·¯ã€‚
    /// Place a blinded bid with `_blindedBid` = keccak256(value,
    /// fake, secret).
    /// The sent ether is only refunded if the bid is correctly
    /// revealed in the revealing phase. The bid is valid if the
    /// ether sent together with the bid is at least "value" and
    /// "fake" is not true. Setting "fake" to true and sending
    /// not the exact amount are ways to hide the real bid but
    /// still make the required deposit. The same address can
    /// place multiple bids.
    // ä¸€ä¸ªåœ°å€å¯ä»¥åšå¤šä¸ªæŠ•æ ‡ã€‚åªæœ‰è¢«æ­£ç¡®äº®å‡ºçš„æŠ•æ ‡å€¼æ‰ä¼šè¢«è¿”è¿˜ï¼ˆå…¶ä»–çš„æŠ•æ ‡å€¼å°±ä¸è¿”è¿˜äº†å—ï¼Ÿï¼‰ã€‚åªæœ‰é™„å¸¦çš„æŠ•æ ‡å€¼å¤§äºç­‰äºvalueï¼ˆè¿™æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿï¼‰è€Œä¸” fake ä¸æ˜¯ trueã€‚è®¾ç½® fake ä¸º true è€Œä¸”å‘é€ä¸å‡†ç¡®çš„æ•°é¢æ˜¯éšè—çœŸå®æŠ•æ ‡ä½†æ»¡è¶³è¦æ±‚çš„é”å®šå­˜æ¬¾çš„æ–¹æ³•ã€‚
    function bid(bytes32 _blindedBid)
        public
        payable
        onlyBefore(biddingEnd)
    {
        bids[msg.sender].push(Bid({
            blindedBid: _blindedBid,
            deposit: msg.value
        }));
    }
    
    // äº®æ ‡ã€‚ç”¨æˆ·å¯ä»¥å¾—åˆ°æ‰€æœ‰è¢«æ­£ç¡®æ©ç›–çš„é”™æ ‡ï¼Œå’Œé™¤äº†æœ€é«˜æ ‡ä»¥å¤–çš„æ‰€æœ‰æ ‡ã€‚
    /// Reveal your blinded bids. You will get a refund for all
    /// correctly blinded invalid bids and for all bids except for
    /// the totally highest.
    function reveal(
        uint[] _values,
        bool[] _fake,
        bytes32[] _secret
    )
        public
        onlyAfter(biddingEnd)
        onlyBefore(revealEnd)
    {
        uint length = bids[msg.sender].length;
        require(_values.length == length);
        require(_fake.length == length);
        require(_secret.length == length);

        uint refund;
        for (uint i = 0; i < length; i++) {
            var bid = bids[msg.sender][i];
            var (value, fake, secret) =
                    (_values[i], _fake[i], _secret[i]);
            if (bid.blindedBid != keccak256(value, fake, secret)) {
                // Bid was not actually revealed.
                // Do not refund deposit.
                continue;
            }
            refund += bid.deposit;
            // deposit æ˜¯å®é™…å­˜å…¥çš„é”å®šä»·å€¼ï¼Œvalue æ˜¯ç”¨æ¥åšæ•£åˆ—ç§å­çš„å£°ç§°ä»·å€¼
            if (!fake && bid.deposit >= value) {
                if (placeBid(msg.sender, value))
                    refund -= value;
            }
            // å› ä¸ºä»¥å¤ªåŠå¯ä»¥è¢«è®¤ä¸ºæ˜¯åºåˆ—åŒ–çš„äº‹åŠ¡éš”ç¦»çº§åˆ«çš„ï¼Œæ‰€ä»¥åœ¨è¿™é‡Œç½®é›¶å¯ä»¥æŠ—å¹¶å‘é—®é¢˜
            // Make it impossible for the sender to re-claim
            // the same deposit.
            bid.blindedBid = bytes32(0);
        }
        msg.sender.transfer(refund);
    }

    // internal çš„ç¬¬ä¸€ä¸ªç”¨æ³•ï¼Œinternal å‡½æ•°ç±»ä¼¼ privateï¼Œåªèƒ½åœ¨åˆçº¦å†…éƒ¨ä½¿ç”¨äº†ã€‚
    // This is an "internal" function which means that it
    // can only be called from the contract itself (or from
    // derived contracts).
    function placeBid(address bidder, uint value) internal
            returns (bool success)
    {
        // ä¸ä¸­æ ‡ã€‚æ‰€ä»¥åœ¨è¿™é‡Œ place å°±æ˜¯æ”¾æ ‡çš„æ„æ€ï¼Ÿ
        if (value <= highestBid) {
            return false;
        }
        if (highestBidder != 0) {
            // å…ˆæŠŠä¹‹å‰çš„æœ€é«˜æ ‡æ”¾è¿›é€€æ¬¾åå•é‡Œé¢
            // Refund the previously highest bidder.
            pendingReturns[highestBidder] += highestBid;
        }
        // æ›¿æ¢æœ€é«˜æ ‡
        highestBid = value;
        highestBidder = bidder;
        return true;
    }

    /// Withdraw a bid that was overbid.
    function withdraw() public {
        uint amount = pendingReturns[msg.sender];
        if (amount > 0) {
            // It is important to set this to zero because the recipient
            // can call this function again as part of the receiving call
            // before `transfer` returns (see the remark above about
            // conditions -> effects -> interaction).
            pendingReturns[msg.sender] = 0;

            msg.sender.transfer(amount);
        }
    }
    
    // åœ¨æ‹å–ç»“æŸçš„æ—¶å€™æŠŠæŠ•æ ‡æ¬¾è½¬èµ°ã€‚
    /// End the auction and send the highest bid
    /// to the beneficiary.
    function auctionEnd()
        public
        onlyAfter(revealEnd)
    {
        require(!ended);
        AuctionEnded(highestBidder, highestBid);
        ended = true;
        beneficiary.transfer(highestBid);
    }
}
```

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæ¯ä¸ªåˆçº¦åªæœ‰ä¸€ä¸ª payable æ–¹æ³•ã€‚
    
### å®‰å…¨çš„è¿œç¨‹è´­ä¹° ###

```javascript
pragma solidity ^0.4.11;

contract Purchase {
    uint public value;
    address public seller;
    address public buyer;
    enum State { Created, Locked, Inactive }
    State public state;

    // ç¡®è®¤ä»·å€¼æ˜¯å¶æ•°ï¼ˆä¸ºä»€ä¹ˆï¼Ÿï¼‰ã€‚ç”±å–æ–¹åˆå§‹åŒ–åˆçº¦ã€‚è¿™æ˜¯ç¬¬ä¸€ä¸ªæ„é€ å‡½æ•°ä¹Ÿæ˜¯ payable çš„åˆçº¦ã€‚åˆå§‹åŒ–åˆçº¦çš„ valueï¼Œå¤§è‡´ç­‰äºä¸€ä¸ªä¹°å–çš„æŠ¼é‡‘ã€‚
    // Ensure that `msg.value` is an even number.
    // Division will truncate if it is an odd number.
    // Check via multiplication that it wasn't an odd number.
    function Purchase() public payable {
        seller = msg.sender;
        value = msg.value / 2;
        require((2 * value) == msg.value);
    }

    modifier condition(bool _condition) {
        require(_condition);
        _;
    }

    modifier onlyBuyer() {
        require(msg.sender == buyer);
        _;
    }

    modifier onlySeller() {
        require(msg.sender == seller);
        _;
    }

    modifier inState(State _state) {
        require(state == _state);
        _;
    }

    event Aborted();
    event PurchaseConfirmed();
    event ItemReceived();

    /// Abort the purchase and reclaim the ether.
    /// Can only be called by the seller before
    /// the contract is locked.
    function abort()
        public
        onlySeller
        inState(State.Created)
    {
        Aborted();
        state = State.Inactive;
        // è¿™ä¸ª balance å°±æ˜¯åˆçº¦è‡ªå¸¦çš„æ‰€æœ‰ balance äº†ï¼Œè€Œä¸æ˜¯æˆ‘ä»¬è‡ªå®šä¹‰çš„ value ä¸€ç±»çš„æˆå‘˜å˜é‡ã€‚
        seller.transfer(this.balance);
    }
    
    /// Confirm the purchase as buyer.
    /// Transaction has to include `2 * value` ether.
    /// The ether will be locked until confirmReceived
    /// is called.
    function confirmPurchase()
        public
        inState(State.Created)
        condition(msg.value == (2 * value))
        payable
    {   
        // å‘å‡ºè´­ä¹°é”å®šäº‹ä»¶
        PurchaseConfirmed();
        buyer = msg.sender;
        state = State.Locked;
    }

    /// Confirm that you (the buyer) received the item.
    /// This will release the locked ether.
    function confirmReceived()
        public
        onlyBuyer
        inState(State.Locked)
    {
        // å‘å‡ºäº‹ä»¶
        ItemReceived();
        // It is important to change the state first because
        // otherwise, the contracts called using `send` below
        // can call in again here.
        state = State.Inactive;

        // NOTE: This actually allows both the buyer and the seller to
        // block the refund - the withdraw pattern should be used.
        // æŠŠæŠ¼é‡‘è½¬ç»™ä¹°å®¶ï¼ŒæŠŠå·®é¢äº¤ç»™å–å®¶ã€‚ä¸ºä»€ä¹ˆè¦è¿™æ ·è®¾è®¡ï¼Ÿä¸ºäº†é¿å…ç©ºå£æ— å‡­çš„å–å®¶æµªè´¹åˆçº¦ä»·å€¼ï¼Ÿ
        buyer.transfer(value);
        seller.transfer(this.balance);
    }
}
```

è¿™è¶³ä»¥è¯æ˜ä¸€ä¸ªåˆçº¦æœ‰å¥½å‡ ä¸ª payable æ–¹æ³•ï¼Œå…è®¸å¤šè§’è‰²åšå¼ˆäº†ã€‚
è¿™ä¸ªåˆçº¦æ²¡æœ‰ä»»ä½•çš„ internal å‡½æ•°ã€‚

## æ·±å…¥Solidity ##

### Solidity æºæ–‡ä»¶çš„è½®å»“ ###

æºæ–‡ä»¶å¯ä»¥åŒ…å«ä»»æ„å¤šçš„åˆçº¦å®šä¹‰ã€‚

#### ç‰ˆæœ¬ pragma ####

```
// è¿™ä¸ªå°–è§’å·æ„å‘³ç€ä¸èƒ½ç”¨é«˜äº0.5.0çš„ç¼–è¯‘å™¨ç¼–è¯‘ã€‚è¿™ä¸ªæ•°å­—è¯´æ˜äº†åˆçº¦çš„æœ€å°ç¼–è¯‘å™¨ç¼–è¯‘å™¨æ˜¯0.4.0ã€‚æ¢è¨€ä¹‹ï¼Œè¦ç”¨é«˜çº§ç¼–è¯‘å™¨ï¼Œè¦ bump up è¿™ä¸ªæ•°å­—ã€‚
pragma solidity ^0.4.0;
```

### å¼•å…¥å…¶ä»–æºæ–‡ä»¶ ###

#### è¯­æ³•å’Œè¯­ä¹‰ ####

Solidity ç”¨ç±»ä¼¼ JavaScript çš„å¼•å…¥è¯­æ³•ï¼Œä½†ä¸æ”¯æŒâ€œdefault exportâ€ã€‚åœ¨å…¨å±€å±‚æ¬¡ï¼Œä½ å¯ä»¥ç”¨ä»¥ä¸‹å½¢å¼çš„å¼•å…¥è¯­å¥ï¼š
```
import "filename";
```
è¿™ä¸ªè¯­å¥æŠŠè¯¥æ–‡ä»¶åä¸‹æ‰€æœ‰çš„**å…¨å±€**ç¬¦å·å¼•å…¥åˆ°å½“å‰çš„**å…¨å±€**ä½œç”¨åŸŸä¸­ã€‚
```
import * as symbolName from "filename";
```
è¿™ä¸ªè¯­å¥åˆ¶é€ äº†ä¸€ä¸ªæ–°çš„å…¨å±€ç¬¦å·ï¼Œç±»ä¼¼åå­—ç©ºé—´ï¼Œæ‰€æœ‰è¯¥æ–‡ä»¶åä¸‹çš„ç¬¦å·ï¼Œéƒ½æ˜¯è¿™ä¸ªæ–°çš„å…¨å±€ç¬¦å·çš„æˆå‘˜ã€‚å®ƒå’Œ`import "filename" as symbolName;`ç­‰ä»·ã€‚
```
import {symbol1 as alias, symbol2} from "filename";
```
éƒ¨åˆ†å¼•ç”¨å’Œåˆ«åæœºåˆ¶ã€‚

#### è·¯å¾„ ####

.å’Œ..çš„æœºåˆ¶åŒ Unix ç³»ç»Ÿã€‚

è¦å¼•ç”¨åŒä¸€ä¸ªæ–‡ä»¶å¤¹ä¸‹çš„æ–‡ä»¶ï¼Œç”¨è¿™æ ·çš„è¯­æ³•`mport "./x" as x;`ã€‚å¦‚æœä½ ä½¿ç”¨äº†`import "x" as x;`ï¼Œä¸€ä¸ªå…¨å±€çš„â€œinclude directoryâ€é‡Œçš„åŒåæ–‡ä»¶å¤¹ä¼šè¢«å¼•ç”¨ã€‚

#### é‡æ˜ å°„é—®é¢˜ ####

å¤ªæ— èŠï¼Œç›´æ¥çœ‹æ–‡æ¡£å§ã€‚

#### æ³¨é‡Šé—®é¢˜ ####

æ³¨æ„çœ‹ä¸‹é¢çš„æ–‡æ¡£ï¼Œå±•ç¤ºäº†å¦‚ä½•å†™æ³¨é‡Šï¼Œä¹Ÿå±•ç¤ºäº†å¦‚ä½•å†™å¤šè¿”å›å€¼ã€‚

```
pragma solidity ^0.4.0;

/** @title Shape calculator. */
contract shapeCalculator {
    /** @dev Calculates a rectangle's surface and perimeter.
      * @param w Width of the rectangle.
      * @param h Height of the rectangle.
      * @return s The calculated surface.
      * @return p The calculated perimeter.
      */
    function rectangle(uint w, uint h) returns (uint s, uint p) {
        s = w * h;
        p = 2 * (w + h);
    }
}
```

### åˆçº¦çš„ç»“æ„ ###

åˆçº¦å’Œé¢å‘å¯¹è±¡ç¨‹åºè®¾è®¡è¯­è¨€é‡Œé¢çš„ class å¾ˆç›¸ä¼¼ã€‚æ¯ä¸ªåˆçº¦å¯ä»¥åŒ…å«[çŠ¶æ€å˜é‡][2]ã€[å‡½æ•°][3]ã€[å‡½æ•°ä¿®é¥°ç¬¦][4]ã€[äº‹ä»¶][5]ã€[ç»“æ„ç±»å‹][6]å’Œ[æšä¸¾ç±»å‹][7]çš„å£°æ˜ã€‚

#### çŠ¶æ€å˜é‡ ####

çŠ¶æ€å˜é‡ä¼šè¢«æŒä¹…åŒ–åœ¨åˆçº¦å­˜å‚¨ï¼ˆçŠ¶æ€ï¼‰é‡Œï¼š
```
pragma solidity ^0.4.0;

contract SimpleStorage {
    uint storedData; // State variable
    // ...
}
```

#### å‡½æ•° ####

å‡½æ•°æ˜¯ä»£ç çš„å¯æ‰§è¡Œå•å…ƒã€‚
```
pragma solidity ^0.4.0;

contract SimpleAuction {
    function bid() public payable { // Function
        // ...
    }
}
```
[å‡½æ•°è°ƒç”¨][8]å¯ä»¥åœ¨å†…éƒ¨å‘ç”Ÿï¼Œä¹Ÿå¯ä»¥åœ¨å¤–éƒ¨å‘ç”Ÿï¼Œè€Œä¸”é¢å¯¹ä¸åŒçš„å…¶ä»–åˆçº¦å¯ä»¥æ‹¥æœ‰ä¸åŒçš„[å¯è§æ€§][9]ã€‚

#### å‡½æ•°ä¿®é¥°ç¬¦ ####

å‡½æ•°ä¿®é¥°ç¬¦å¯ä»¥ä»¥å£°æ˜çš„æ–¹å¼ä¿®é¥°å‡½æ•°çš„è¯­ä¹‰ï¼ˆè§[Function Modifiers][10]éƒ¨åˆ†ï¼‰ã€‚

```
pragma solidity ^0.4.11;

contract Purchase {
    address public seller;
    
    // æ€»æ˜¯é…åˆ require å‡½æ•°ä½¿ç”¨ã€‚è¿˜å¯ä»¥çœ‹çœ‹ revert ä»€ä¹ˆçš„å‡½æ•°ã€‚
    modifier onlySeller() { // Modifier
        require(msg.sender == seller);
        _;
    }

    function abort() public onlySeller { // Modifier usage
        // ...
    }
}
```

#### äº‹ä»¶ ####

äº‹ä»¶å°±æ˜¯æ‹¿æ¥å’Œ EVM æ—¥å¿—è®¾æ–½æ‰“äº¤é“çš„æ–¹ä¾¿æ¥å£ã€‚

```
pragma solidity ^0.4.0;

contract SimpleAuction {
    event HighestBidIncreased(address bidder, uint amount); // Event

    function bid() public payable {
        // ...
        HighestBidIncreased(msg.sender, msg.value); // Triggering event
    }
}
```

#### Struct ç±»å‹ ####

ç±»ä¼¼ C è¯­è¨€ï¼Œæ˜¯åŸºæœ¬ç±»å‹çš„å°è£…ç»„åˆã€‚

```
pragma solidity ^0.4.0;

contract Ballot {
    struct Voter { // Struct
        uint weight;
        bool voted;
        address delegate;
        uint vote;
    }
}
```

#### æšä¸¾ç±»å‹ ####

ä¾ç„¶ç±»ä¼¼ Javaã€‚

```
pragma solidity ^0.4.0;

contract Purchase {
    enum State { Created, Locked, Inactive } // Enum
}
```

### ç±»å‹ ###

Solidity æ˜¯é™æ€ç±»å‹è¯­è¨€ï¼Œè¿™æ„å‘³ç€ä¸ç®¡æ˜¯çŠ¶æ€å˜é‡è¿˜æ˜¯å±€éƒ¨å˜é‡ï¼Œæ¯ä¸ªå˜é‡çš„ç±»å‹å¿…é¡»åœ¨è¿è¡Œæ—¶è¢«æŒ‡å®šå¥½ï¼ˆè‡³å°‘æ˜¯å·²çŸ¥çš„ï¼Œè§[Type Deduction][11]ï¼‰ã€‚Solidity æä¾›å‡ ä¸ªè‡³å…³é‡è¦çš„ç±»å‹ï¼Œå¯ä»¥è¢«ç»„åˆæˆå¤åˆç±»å‹ã€‚

#### å€¼ç±»å‹ ####

ä»¥ä¸‹çš„ç±»å‹æ€»æ˜¯è¢«ç§°ä½œå€¼ç±»å‹ï¼Œå› ä¸ºè¿™äº›ç±»å‹çš„å˜é‡æ€»æ˜¯ä¼šè¢«ä¼ å€¼ã€‚ä»–ä»¬ä½œä¸ºå‡½æ•°å‚æ•°æˆ–è€…èµ‹å€¼ä½¿ç”¨çš„æ—¶å€™ï¼Œæ€»æ˜¯ä¼šè¢«æ‹·è´ã€‚

##### å¸ƒå°”ç±»å‹ #####

boolï¼šå¯èƒ½å€¼ä¸ºå¸¸é‡ true æˆ–è€… falseã€‚

é€»è¾‘æ“ä½œç¬¦å’Œå¸¸è§çš„ç¼–ç¨‹è¯­è¨€æ“ä½œç¬¦ç±»ä¼¼ï¼Œä¹Ÿæ”¯æŒ**çŸ­è·¯æ“ä½œ**ã€‚

##### æ•´å‹ #####
`int`/`uint`ï¼šå„ç§å°ºå¯¸çš„æœ‰ç¬¦å·å’Œæ— ç¬¦å·æ•´å‹æ•°ã€‚å…³é”®å­—`uint8`å’Œ `unint256`ä»¥8ä½ä¸ºæ­¥é•¿ï¼Œä»¥åŠ`int8`å’Œ`int256`ã€‚ç›¸å¯¹åœ°ï¼Œ`unint`å’Œ`int`æ˜¯`uint256`å’Œ`int256`çš„åˆ«åï¼ˆæŒ‰ï¼šå³é»˜è®¤æ•°æ®å®½åº¦å°±æ˜¯æœ€å®½ï¼‰ã€‚

é™¤æ³•æ€»æ˜¯ä¼šé€ æˆæˆªæ–­ï¼Œé™¤éä¸¤ä¸ªæ“ä½œç¬¦éƒ½æ˜¯å­—é¢é‡ï¼ˆï¼Ÿï¼‰æˆ–è€…å­—é¢é‡è¡¨è¾¾å¼ã€‚

`x << y`ç­‰äº`x * 2**y`ï¼Œè€Œ`x >> y`ç­‰äº`x / 2**y`ã€‚ç”¨è´Ÿæ•°ä½œ y å¯èƒ½ä¼šå‡ºè¿è¡Œæ—¶å¼‚å¸¸-è¿™æ˜¯å› ä¸ºä¸åŒç¼–ç¨‹è¯­è¨€çš„ç§»ä½æœ‰å‘0å’Œå‘è´Ÿæ— ç©·ç§»ä½çš„åŒºåˆ«ã€‚

##### å®šç‚¹æ•° #####

å®šç‚¹æ•°åœ¨ Solidity é‡Œè¿˜æ²¡è¢«å®Œå…¨æ”¯æŒã€‚å®ƒä»¬å¯ä»¥è¢«å£°æ˜ï¼Œä½†ä¸èƒ½è¢«æ‹¿æ¥èµ‹å€¼æˆ–è€…å–å€¼ã€‚


`fixed`/`ufixed`è¡¨è¾¾çš„æ˜¯ä¸åŒå°ºå¯¸çš„æœ‰ç¬¦å·å’Œæ— ç¬¦å·å®šç‚¹æ•°ã€‚å…³é”®å­—`ufixedMxN`å’Œ`fixedMxN`é‡Œï¼Œ`M` ä»£è¡¨è¿™ä¸ªç±»å‹å¯ä»¥ä½¿ç”¨çš„ä½æ•°ï¼Œè€Œ`N`ä»£è¡¨çš„æ˜¯æœ‰å¤šå°‘ä¸ªå°æ•°ä½å¯è¢«ä½¿ç”¨ã€‚`M`å¿…é¡»å¯è¢«8æ•´é™¤ï¼Œä»8å¢é•¿åˆ°256ã€‚`N`å¿…é¡»åœ¨0åˆ°80ä¹‹é—´ã€‚ç›¸åº”åœ°ï¼Œ`ufixed`å’Œ`fixed`æ˜¯`ufixed128x19` å’Œ `fixed128x19`çš„åˆ«åã€‚

æµ®ç‚¹æ•°ï¼ˆIEEE 754ï¼‰çš„å°æ•°ç‚¹ä½ç½®æ˜¯å¯å˜çš„ï¼Œè€Œå®šç‚¹æ•°æ˜¯ä¸å¯å˜çš„ã€‚

##### åœ°å€ç±»å‹

åœ°å€æ‹¥æœ‰20å­—èŠ‚çš„æ•°æ®ï¼Œå®ƒä¹Ÿæœ‰æˆå‘˜ï¼Œè€Œä¸”åœ¨0.5.0ä»¥å‰æ˜¯æ‰€æœ‰åˆçº¦çš„åŸºç±»ã€‚åœ¨0.5.0ä¹‹åï¼Œåˆçº¦ç±»å‹ä¸å†ä»åœ°å€ç±»å‹é‡Œè¡ç”Ÿå‡ºæ¥ï¼Œä½†å¯ä»¥è¢«æ˜¾å¼åœ°è½¬åŒ–ä¸ºåœ°å€ã€‚

åœ°å€çš„æˆå‘˜ï¼š

- balance`å’Œ`transfer

```javascript
address x = 0x123;
address myAddress = this;
if (x.balance < 10 && myAddress.balance >= 10) x.transfer(10);
```

**ç‰¹åˆ«åœ°ï¼Œå‘åˆçº¦åœ°å€è°ƒç”¨ transfer çš„æ—¶å€™ï¼Œæ¯ä¸ªåˆçº¦åœ°å€çš„ fallback å‡½æ•°ä¼šè¢«è°ƒç”¨ã€‚**

- send æ˜¯ transfer ä½çº§å¯¹åº”ç‰©ã€‚å¦‚æœæ‰§è¡Œå¤±è´¥ï¼Œtransfer æŠ›å‡ºå¼‚å¸¸è€Œ send è¿”å› falseã€‚

- call, callcode and delegatecall

call å¯ä»¥ä½¿ç”¨ä»»æ„æ•°é‡ä»»æ„ç±»å‹çš„å‚æ•°å’Œæ¥å£äº¤äº’ã€‚

```javascript
address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;
nameReg.call("register", "MyName");
nameReg.call(bytes4(keccak256("fun(uint256)")), a);
```
ä¿®æ”¹æä¾›çš„ gas æ•°é‡çš„å‡½æ•°ï¼š
```javascript
namReg.call.gas(1000000)("register", "MyName");
```
ç±»ä¼¼åœ°ï¼Œä¹Ÿå¯ä»¥åœ¨è°ƒç”¨å‡½æ•°çš„æ—¶å€™è½¬é’±ï¼š
```
nameReg.call.value(1 ether)("register", "MyName");
```
æ— å…³é¡ºåºçš„ä¿®é¥°ç¬¦ä½¿ç”¨ï¼š
```
nameReg.call.gas(1000000).value(1 ether)("register", "MyName");
```

delegatecallå¯ä»¥è¢«ç”¨æ¥è°ƒç”¨æŸä¸ªç‰¹å®šåˆçº¦ä¸Šçš„åœ°å€ï¼Œè¿™ä¸ªæ–¹æ³•çš„ç”¨æ„å°±æ˜¯ç”¨æ¥è°ƒç”¨å…¶ä»–åˆçº¦ä¸Šçš„åº“å‡½æ•°ã€‚å®ƒçš„æ—©æœŸç‰ˆæœ¬ï¼ˆå®¶å›­ä»¥å‰ï¼‰callcode åŒç†ï¼Œè€Œä¸”callcode ä¸èƒ½è®¿é—®`msg.sender`å’Œ`msg.value`ã€‚**callcode å°†åœ¨æœªæ¥çš„ç‰ˆæœ¬è¢«ç§»é™¤ã€‚**

å°½é‡åº”è¯¥ä½¿ç”¨ transfer è€Œä¸è¦ä½¿ç”¨ä½çº§ APIï¼Œå› ä¸ºå®ƒä»¬ç ´åäº† Solidity çš„ç±»å‹å®‰å…¨ã€‚

`.gas()`é€‰é¡¹å¯¹äºä¸‰ä¸ªæ–¹æ³•éƒ½å¯ç”¨ï¼Œä½†`.value()`é€‰é¡¹ä¸è¢«`delegatecall`æ‰€æ”¯æŒã€‚

å› ä¸ºæ‰€æœ‰çš„åˆçº¦éƒ½é›†æˆäº†åœ°å€çš„æˆå‘˜ï¼Œæ‰€ä»¥åœ¨åˆçº¦é‡Œå¯ä»¥è¿™æ ·æŸ¥ä½™é¢`this.balance`ã€‚

##### å®šé•¿å­—èŠ‚æ•°ç»„

`bytes1`ï¼Œ`bytes2`ï¼Œ`bytes3`ï¼Œ...ï¼Œ`bytes32`ã€‚ `byte` æ˜¯ `bytes1`çš„åˆ«åã€‚

è¿™ä¸ªç±»å‹ä¹Ÿæ”¯æŒå¸¸è§çš„æ¯”è¾ƒã€ä½æ“ä½œç¬¦ï¼Œå®ƒè¿˜æ”¯æŒæ›´é‡è¦çš„ç´¢å¼•æ“ä½œç¬¦ï¼šå¦‚æœ x æ˜¯ä¸ª`bytesI`ç±»å‹ï¼Œ`x[k]`(`0 <= k < I`)è¿”å›ç¬¬ k
ä¸ªå­—èŠ‚ã€‚

##### åŠ¨æ€é•¿åº¦å­—èŠ‚æ•°ç»„

`bytes`ï¼šåŠ¨æ€é•¿åº¦å­—èŠ‚æ•°ç»„ï¼Œè§[Arrays][12]ã€‚ä¸æ˜¯ä¸€ä¸ªå€¼ç±»å‹ï¼ˆä¸ºä»€ä¹ˆè¦æ”¾è¿™é‡Œï¼Ÿï¼‰ã€‚

`string`ï¼šåŠ¨æ€utf-8ç¼–ç å­—ç¬¦ä¸²ï¼Œè§[Arrays][13]ã€‚ä¸æ˜¯ä¸€ä¸ªå€¼ç±»å‹ï¼ˆä¸ºä»€ä¹ˆè¦æ”¾è¿™é‡Œï¼Ÿï¼‰ã€‚

å¦‚æœæœ‰ä»»æ„é•¿åº¦æ•°æ®çš„éœ€æ±‚ï¼Œåº”è¯¥ä¼˜å…ˆä½¿ç”¨`bytes`å’Œ`string`ï¼Œå¦åˆ™å°½é‡ä½¿ç”¨å®šé•¿çš„æ•°æ®æ•°æ®ç±»å‹ï¼Œ`bytes1`å’Œ`bytes32`æ¯”è¾ƒä¾¿å®œã€‚

##### åœ°å€å­—é¢é‡

èƒ½å¤Ÿé€šè¿‡åœ°å€æµ‹è¯•çš„åå…­è¿›åˆ¶å­—é¢é‡ï¼ˆåŠ ä¸Š0xé•¿åº¦ä¸º42çš„å­—ç¬¦ä¸²ï¼‰å¦‚`0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF`æ˜¯ åœ°å€ç±»å‹ã€‚

##### æœ‰ç†æ•°å’Œæ•´æ•°å­—é¢é‡

å¸¸è§æ•´æ•°å­—é¢é‡ï¼š`69`ã€‚
åè¿›ä½å°æ•°å­—é¢é‡ï¼š`1.3`ã€‚
ç§‘å­¦è®¡æ•°æ³•ï¼š`2e10`ï¼Œ`-2e10`ï¼Œ`2e-10`ï¼Œ`2.5e1.`ã€‚

æ—©æœŸç‰ˆæœ¬çš„æœ‰ç†æ•°é™¤æ³•ä¼šå¯¼è‡´æˆªæ–­ï¼Œå½“å‰ç‰ˆæœ¬ä¸ä¼šï¼Œ`5/2`ç°åœ¨ç­‰äº2.5äº†ã€‚

##### å­—ç¬¦ä¸²å­—é¢é‡

å•å¼•å·å’ŒåŒå¼•å·éƒ½å¯ä»¥åŒ…è£¹å­—ç¬¦ä¸²å­—é¢é‡ï¼Œå¦‚`"foo"`å’Œ`'bar'`ã€‚ä»–ä»¬æ²¡æœ‰ C ä¸­çš„å°¾éš0ã€‚`"foo"`ä»£è¡¨ä¸‰ä¸ªå­—èŠ‚è€Œä¸æ˜¯å››ä¸ªã€‚ä»–ä»¬å¯ä»¥è¢«éšå¼åœ°è½¬æ¢ä¸ºå„ç§å­—èŠ‚æ•°ç»„ï¼ˆè§ä¸Šæ–‡ï¼‰ï¼Œå®šé•¿ä¸å®šé•¿çš„éƒ½å¯èƒ½ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥è½¬åŒ–ä¸º`string`ã€‚

å­—ç¬¦ä¸²å­—é¢é‡æ”¯æŒè½¬ä¹‰ç¬¦ï¼Œå¦‚`\n`ï¼Œ`\xNN`å’Œ`\uNNNN`ã€‚`\xNN`å–ä¸€ä¸ªåå…­è¿›åˆ¶çš„å€¼ï¼Œå¹¶æ’å…¥ä¸€ä¸ªæ­£ç¡®çš„å­—èŠ‚ã€‚`\uNNNN`å–ä¸€ä¸ª Unicode ç ç‚¹ï¼Œå¹¶ä¸”æ’å…¥ä¸€ä¸ªUTF-8åºæ•°ã€‚

##### åå…­è¿›åˆ¶å­—é¢é‡

ç”¨`hex`å¼€å¤´ï¼Œç”¨å•åŒå¼•å·æ‹¬èµ·æ¥ï¼š`hex"001122FF"`ã€‚

##### æšä¸¾

è¿™é‡Œçš„æšä¸¾ä¹Ÿæ˜¯å¯ä»¥æ˜¾å¼åœ°ä¸æ•´å‹æ•°äº’ç›¸è½¬æ¢çš„ã€‚

```
pragma solidity ^0.4.16;

contract test {
    enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }
    ActionChoices choice;
    ActionChoices constant defaultChoice = ActionChoices.GoStraight;

    function setGoStraight() public {
        choice = ActionChoices.GoStraight;
    }

    // Since enum types are not part of the ABI, the signature of "getChoice"
    // will automatically be changed to "getChoice() returns (uint8)"
    // for all matters external to Solidity. The integer type used is just
    // large enough to hold all enum values, i.e. if you have more values,
    // `uint16` will be used and so on.
    function getChoice() public view returns (ActionChoices) {
        return choice;
    }

    function getDefaultChoice() public pure returns (uint) {
        return uint(defaultChoice);
    }
}
```

##### å‡½æ•°ç±»å‹

åŒå‡½æ•°å¼ç¼–ç¨‹é‡Œé¢çš„ä¸€ç­‰ç±»å‹å‡½æ•°å·®ä¸å¤šã€‚

å‡½æ•°ç±»å‹è¢«åˆ†ä¸ºä¸¤ç§ï¼šå†…éƒ¨å’Œå¤–éƒ¨å‡½æ•°ã€‚

å†…éƒ¨å‡½æ•°åªèƒ½åœ¨å½“å‰åˆçº¦å†…è¢«è°ƒç”¨ï¼ˆæ›´å…·ä½“åœ°è¯´ï¼Œåœ¨å½“å‰çš„ä»£ç å•å…ƒå†…ï¼Œä¹Ÿå°±åŒ…å«äº†å†…éƒ¨å‡½æ•°åº“å’Œç»§æ‰¿ä¸‹æ¥çš„å‡½æ•°ï¼‰ï¼Œå› ä¸ºä»–ä»¬ä¸èƒ½åœ¨å½“å‰åˆçº¦çš„ä¸Šä¸‹æ–‡ä¹‹å¤–è¢«æ‰§è¡Œã€‚è°ƒç”¨ä¸€ä¸ªå†…éƒ¨å‡½æ•°çš„å®ç°æ–¹å¼å°±æ˜¯è®©æ§åˆ¶æµè·³åˆ°ä¸€ä¸ªæ¡ç›®æ ‡ç­¾ä¸Šã€‚

å¤–éƒ¨å‡½æ•°åŒ…æ‹¬ä¸€ä¸ªåœ°å€å’Œä¸€ä¸ªå‡½æ•°ç­¾åï¼Œä»–ä»¬å¯ä»¥è¢«ä¼ é€’è¿›/ä¼ é€’å‡ºå¤–éƒ¨å‡½æ•°è°ƒç”¨ã€‚

å‡½æ•°ç±»å‹çš„æ ‡è®°æ³•æ˜¯ï¼š

```
function (<parameter types>) {internal|external} [pure|constant|view|payable] [returns (<return types>)]
```

ä¸å…è®¸å‡ºç°ç©ºçš„ return è¯­å¥ã€‚

é»˜è®¤å‡½æ•°éƒ½æ˜¯ internal çš„ï¼Œæ‰€ä»¥ internal å®é™…ä¸Šå¯ä»¥è¢«çœç•¥ï¼ˆç±»ä¼¼ C è¯­è¨€å‘¢ï¼‰ã€‚

`delete`ä¸€ä¸ªå‡½æ•°åï¼Œå†è°ƒç”¨å®ƒä¼šå‡ºç°è¿è¡Œæ—¶å¼‚å¸¸ã€‚

å¦‚æœä¸€ä¸ªå¤–éƒ¨å‡½æ•°å˜é‡è¢« Solidity ä¹‹å¤–çš„ä¸Šä¸‹æ–‡è°ƒç”¨ï¼ˆè·¨è¯­è¨€äº’æ“ä½œ interoperabilityé—®é¢˜ï¼‰ï¼Œä»–ä»¬å°†è¢«å½“åš`function`ç±»å‹ï¼Œå®ƒåœ¨ä¸€ä¸ª`bytes24`ç±»å‹é‡Œæ”¾äº†ä¸€ä¸ªç¼–ç çš„åœ°å€ï¼Œåé¢è¿˜è·Ÿç€å‡½æ•°è¯†åˆ«ç¬¦ã€‚

publicï¼ˆæˆ–å¤–éƒ¨ï¼‰å‡½æ•°åŒæ ·åŒ…å«ä¸€ä¸ªå«`selector`çš„æˆå‘˜ï¼Œå®ƒè¿”å›ä¸€ä¸ª [ABI function selector][14]

```
pragma solidity ^0.4.16;

contract Selector {
  function f() public view returns (bytes4) {
    return this.f.selector;
  }
}
```

å†…éƒ¨å‡½æ•°çš„ä¾‹å­ï¼š
```
pragma solidity ^0.4.16;

library ArrayUtils {
  // åŒåœ¨ä¸€ä¸ªä¸Šä¸‹æ–‡é‡Œçš„å†…éƒ¨å‡½æ•°è°ƒç”¨ã€‚
  // internal functions can be used in internal library functions because
  // they will be part of the same code context
  function map(uint[] memory self, function (uint) pure returns (uint) f)
    internal
    pure
    returns (uint[] memory r)
  {
    r = new uint[](self.length);
    for (uint i = 0; i < self.length; i++) {
      r[i] = f(self[i]);
    }
  }
  function reduce(
    uint[] memory self,
    function (uint, uint) pure returns (uint) f
  )
    internal
    pure
    returns (uint r)
  {
    r = self[0];
    for (uint i = 1; i < self.length; i++) {
      r = f(r, self[i]);
    }
  }
  function range(uint length) internal pure returns (uint[] memory r) {
    r = new uint[](length);
    for (uint i = 0; i < r.length; i++) {
      r[i] = i;
    }
  }
}

contract Pyramid {
  using ArrayUtils for *;
  function pyramid(uint l) public pure returns (uint) {
    return ArrayUtils.range(l).map(square).reduce(sum);
  }
  function square(uint x) internal pure returns (uint) {
    return x * x;
  }
  function sum(uint x, uint y) internal pure returns (uint) {
    return x + y;
  }
}
```

ä¸€ä¸ªæŠŠå¤–éƒ¨å‡½æ•°ç±»å‹ä¼ é€’è¿› struct çš„å®ä¾‹ï¼Œè¿™å…¶å®ä¹Ÿæ˜¯ä¸ªé¢„è¨€æœºä½¿ç”¨çš„å¥½ä¾‹å­äº†ï¼š

```
pragma solidity ^0.4.20; // should actually be 0.4.21

contract Oracle {
  struct Request {
    bytes data;
    function(bytes memory) external callback;
  }
  Request[] requests;
  event NewRequest(uint);
  function query(bytes data, function(bytes memory) external callback) public {
    requests.push(Request(data, callback));
    emit NewRequest(requests.length - 1);
  }
  function reply(uint requestID, bytes response) public {
    // Here goes the check that the reply comes from a trusted source
    requests[requestID].callback(response);
  }
}

contract OracleUser {
  Oracle constant oracle = Oracle(0x1234567); // known contract
  function buySomething() {
    oracle.query("USD", this.oracleResponse);
  }
  function oracleResponse(bytes response) public {
    require(msg.sender == address(oracle));
    // Use the data
  }
}
```

ç°åœ¨è¿˜ä¸æ”¯æŒ Lambda å‡½æ•°å’Œå†…è”å‡½æ•°ã€‚

#### å¼•ç”¨ç±»å‹

å¤åˆç±»å‹ï¼Œä¹Ÿå°±æ˜¯ç±»å‹ä¸è¡¬è¿›256ä½çš„ç±»å‹ï¼Œæ€»è¦è¢«æ¯”æˆ‘ä»¬å·²ç»çœ‹åˆ°çš„å€¼ç±»å‹æ›´ä»”ç»†åœ°å¯¹å¾…ã€‚å› ä¸ºæ‹·è´å®ƒä»¬æ˜¯éå¸¸æ˜‚è´µçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦ä»”ç»†è€ƒè™‘å®ƒä»¬åº”è¯¥è¢«å­˜å‚¨åœ¨`memoryé‡Œ`ï¼ˆä¸ä¼šè¢«æŒä¹…åŒ–ï¼‰è¿˜æ˜¯è¢«å­˜å‚¨åœ¨`storage`ï¼ˆçŠ¶æ€å˜é‡å°±æ”¾åœ¨è¿™é‡Œï¼‰é‡Œã€‚

##### æ•°æ®ä½ç½®

æ¯ä¸ªå¤åˆç±»å‹ï¼Œæ•°ç»„å’Œç»“æ„ä½“ï¼Œéƒ½æœ‰ä¸€ä¸ªé¢å¤–çš„æ³¨è§£ï¼Œå³â€œæ•°æ®ä½ç½®â€ï¼Œå…³äºå®ƒæ˜¯è¢«å­˜å‚¨åœ¨memoryé‡Œè¿˜æ˜¯åœ¨storageé‡Œã€‚ä¾æ®ä¸Šä¸‹æ–‡çš„ä¸åŒï¼Œæ€»æœ‰ä¸€ä¸ªç¼ºçœå€¼ï¼Œä½†å®ƒå¯ä»¥è¢«å¾€ç±»å‹ä¸Šæ·»åŠ `storage`å’Œ`memory`è¦†ç›–æ‰ã€‚é»˜è®¤çš„å‡½æ•°å‚æ•°æ˜¯`memory`çš„ï¼Œé»˜è®¤çš„å±€éƒ¨å˜é‡æ˜¯`storage`çš„ï¼ˆå³è¿™ä¸¤è€…æ˜¯å¯å˜çš„ï¼‰ï¼ŒçŠ¶æ€å˜é‡çš„ä½ç½®è¢«å¼ºåˆ¶è®¾ä¸º`storage`ã€‚

è¿˜æœ‰ç¬¬ä¸‰ç§æ•°æ®ä½ç½®ï¼Œ`calldata`ï¼Œå®ƒæ˜¯ä¸å¯ä¿®æ”¹çš„ï¼Œä¸æŒä¹…åŒ–çš„ï¼Œå‡½æ•°å®å‚å­˜å‚¨åœ¨é‡Œé¢ã€‚å¤–éƒ¨å‡½æ•°çš„å‡½æ•°å‚æ•°ï¼ˆè€Œä¸æ˜¯è¿”å›å‚æ•°ï¼‰è¢«å¼ºåˆ¶ä¸º`calldata`ï¼Œè¡Œä¸ºè¡¨ç°ä¸`memory`å¾ˆç›¸ä¼¼ã€‚

æ•°æ®ä½ç½®æ˜¯é‡è¦çš„ï¼Œå› ä¸ºä»–ä»¬æ”¹å˜äº†èµ‹å€¼è¡Œä¸º:`memory`å’Œ`storage`ä¹‹é—´çš„èµ‹å€¼ã€çŠ¶æ€å˜é‡ä¹‹é—´çš„èµ‹å€¼æ€»æ˜¯ä¼šäº§ç”Ÿç‹¬ç«‹æ‹·è´ã€‚å‘å±€éƒ¨`storage` å˜é‡èµ‹å€¼ï¼Œå°½ç®¡åªæ˜¯èµ‹äºˆä¸€ä¸ªå¼•ç”¨ï¼Œè¿™ä¸ªå¼•ç”¨æ€»æ˜¯æŒ‡å‘ä¸€ä¸ªçŠ¶æ€å˜é‡ï¼Œå³ä½¿åè€…ä¼šæ”¹å˜ã€‚`memory`å’Œ`memory`ä¹‹é—´çš„èµ‹å€¼ä¸ä¼šäº§ç”Ÿæ‹·è´ã€‚

```
pragma solidity ^0.4.0;

contract C {
    uint[] x; // the data location of x is storage

    // the data location of memoryArray is memory
    function f(uint[] memoryArray) public {
        x = memoryArray; // works, copies the whole array to storage
        var y = x; // works, assigns a pointer, data location of y is storage
        y[7]; // fine, returns the 8th element
        // å±€éƒ¨ storage å˜é‡ä¿®æ”¹äº†çŠ¶æ€ storage å˜é‡ã€‚
        y.length = 2; // fine, modifies x through y
        // æ¸…é™¤æ•°ç»„çš„æ–¹æ³•
        delete x; // fine, clears the array, also modifies y
        // å¯ä»¥æŠŠå®å‚èµ‹ç»™çŠ¶æ€å˜é‡ï¼ŒæŠŠå±€éƒ¨å˜é‡æŒ‡å‘çŠ¶æ€å˜é‡ï¼Œå´ä¸èƒ½è·³è¿‡ç¬¬ä¸€æ­¥ã€‚çŠ¶æ€å˜é‡éƒ½æ˜¯â€œé™æ€åˆ†é…â€çš„ã€‚
        // The following does not work; it would need to create a new temporary /
        // unnamed array in storage, but storage is "statically" allocated:
        // y = memoryArray;
        // This does not work either, since it would "reset" the pointer, but there
        // is no sensible location it could point to.
        // delete y;
        g(x); // calls g, handing over a reference to x
        h(x); // calls h and creates an independent, temporary copy in memory
    }

    function g(uint[] storage storageArray) internal {}
    function h(uint[] memoryArray) public {}
}
```

åœ¨å®éªŒä¹‹ä¸­ï¼Œæ„é€ å‡½æ•°ç”Ÿæˆçš„æ€»æ˜¯`memory`ç±»å‹çš„å˜é‡ï¼Œæ‹·è´åˆ° storage å˜é‡å°±å¯ä»¥è®©å®ƒè¢«æŒä¹…åŒ–äº†ã€‚

æ€»ç»“ä¸€ä¸‹ï¼š

å¼ºåˆ¶æ•°æ®ä½ç½®ï¼š
å¤–éƒ¨å‡½æ•°çš„å‚æ•°å¿…é¡»æ˜¯`calldata`
çŠ¶æ€å˜é‡å¿…é¡»æ˜¯`storage`
ç¼ºçœæ•°æ®ä½ç½®ï¼š
å‡½æ•°å‚æ•°é»˜è®¤æ˜¯`memory`
æ‰€æœ‰å±€éƒ¨å˜é‡é»˜è®¤æ˜¯`storage`

##### æ•°ç»„

æ•°ç»„å¯ä»¥æœ‰ç¼–è¯‘æ—¶çš„å›ºå®šé•¿åº¦ï¼Œä¹Ÿå¯ä»¥æ˜¯åŠ¨æ€çš„ã€‚`storage`æ•°ç»„çš„å…ƒç´ ç±»å‹å¯ä»¥æ˜¯ä»»æ„çš„ï¼ˆå³å¯ä»¥æ˜¯æ•°ç»„çš„æ•°ç»„ã€mapping çš„æ•°ç»„å’Œç»“æ„ä½“çš„æ•°ç»„ï¼‰ã€‚`memory`æ•°ç»„åˆ™ä¸èƒ½æœ‰`mapping`å…ƒç´ ï¼Œå¦‚æœå®ƒæ˜¯ä¸ªå…¬å…±å¯è§å‡½æ•°ï¼ˆå¤–éƒ¨å‡½æ•°ï¼Ÿï¼‰ï¼Œå®ƒçš„å…ƒç´ å¿…é¡»æ˜¯ä¸ª ABI ç±»å‹ã€‚

å®šé•¿æ•°ç»„å†™ä½œï¼Œ`T[k]`ï¼Œå˜é•¿æ•°ç»„å†™ä½œ`T[]`ï¼ˆä¹Ÿå°±æ˜¯è¯´å¤§éƒ¨åˆ†çš„æ™ºèƒ½åˆçº¦çš„å‡½æ•°å‚æ•°éƒ½æ˜¯`memory`åŠ¨æ€æ•°ç»„ï¼‰ã€‚

5ä¸ª`unint`åŠ¨æ€æ•°ç»„çš„å†™æ³•ä¸å…¶ä»–è¯­è¨€æ­£å¥½åè¿‡æ¥ï¼Œ`uint[][15]`ã€‚è®¿é—®ç¬¬ä¸‰ä¸ªåŠ¨æ€æ•°ç»„çš„ç¬¬äºŒä¸ªå…ƒç´ ï¼Œåˆåè€Œå’Œå…¶å®ƒè¯­è¨€ä¸€æ ·ï¼Œ`x[2][16]`ã€‚

##### åˆ›å»ºå†…å­˜æ•°ç»„

**å¯ä»¥ç”¨ new æ¥åˆ›å»ºå†…å­˜æ•°ç»„**ã€‚`memory`æ•°ç»„ä¸å¯ä»¥é€šè¿‡`.length` æ¥ä¿®æ”¹æ•°ç»„å°ºå¯¸ï¼Œä½†`storage`æ•°ç»„å¯ä»¥ã€‚

```
pragma solidity ^0.4.16;

contract C {
    function f(uint len) public pure {
        uint[] memory a = new uint[](7);
        bytes memory b = new bytes(len);
        // Here we have a.length == 7 and b.length == len
        a[6] = 8;
    }
}
```

##### æ•°ç»„å­—é¢é‡/å†…è”æ•°ç»„

```
pragma solidity ^0.4.16;

contract C {
    function f() public pure {
        g([uint(1), 2, 3]);
    }
    // è¿™ä¹Ÿæ˜¯ä¸ªå®šé•¿æ•°ç»„çš„ä¾‹å­
    function g(uint[3] _data) public pure {
        // ...
    }
}
```

##### æˆå‘˜

lengthï¼šåªæœ‰ storage çš„åŠ¨æ€æ•°ç»„æ‰èƒ½åŠ¨æ€ä¿®æ”¹è‡ªå·±çš„å°ºå¯¸ã€‚
pushï¼šåœ¨æ•°ç»„å°¾éƒ¨æ·»åŠ å…ƒç´ ï¼Œè¿”å›æ–°çš„é•¿åº¦ã€‚

æ•°ç»„çš„ä¸€ä¸ªç»¼åˆä¾‹å­ï¼š

```
pragma solidity ^0.4.16;

contract ArrayContract {
    uint[2**20] m_aLotOfIntegers;
    // Note that the following is not a pair of dynamic arrays but a
    // dynamic array of pairs (i.e. of fixed size arrays of length two).
    bool[2][] m_pairsOfFlags;
    // newPairs is stored in memory - the default for function arguments

    function setAllFlagPairs(bool[2][] newPairs) public {
        // assignment to a storage array replaces the complete array
        m_pairsOfFlags = newPairs;
    }

    function setFlagPair(uint index, bool flagA, bool flagB) public {
        // access to a non-existing index will throw an exception
        m_pairsOfFlags[index][0] = flagA;
        m_pairsOfFlags[index][17] = flagB;
    }

    function changeFlagArraySize(uint newSize) public {
        // if the new size is smaller, removed array elements will be cleared
        m_pairsOfFlags.length = newSize;
    }

    function clear() public {
        // these clear the arrays completely
        delete m_pairsOfFlags;
        delete m_aLotOfIntegers;
        // identical effect here
        m_pairsOfFlags.length = 0;
    }

    bytes m_byteData;

    function byteArrays(bytes data) public {
        // byte arrays ("bytes") are different as they are stored without padding,
        // but can be treated identical to "uint8[]"
        m_byteData = data;
        m_byteData.length += 7;
        m_byteData[3] = byte(8);
        delete m_byteData[2];
    }

    function addFlag(bool[2] flag) public returns (uint) {
        return m_pairsOfFlags.push(flag);
    }

    function createMemoryArray(uint size) public pure returns (bytes) {
        // Dynamic memory arrays are created using `new`:
        uint[2][] memory arrayOfPairs = new uint[2][](size);
        // Create a dynamic byte array:
        bytes memory b = new bytes(200);
        for (uint i = 0; i < b.length; i++)
            b[i] = byte(i);
        return b;
    }
}
```

##### ç»“æ„ä½“ç±»å‹

ç»“æ„ä½“æä¾›äº†å®šä¹‰æ–°ç±»å‹çš„èƒ½åŠ›ã€‚
ä¼—ç­¹åˆçº¦çš„ä¾‹å­ï¼š

```
pragma solidity ^0.4.11;

contract CrowdFunding {
    // Defines a new type with two fields.
    struct Funder {
        address addr;
        uint amount;
    }

    struct Campaign {
        address beneficiary;
        uint fundingGoal;
        uint numFunders;
        uint amount;
        mapping (uint => Funder) funders;
    }

    uint numCampaigns;
    mapping (uint => Campaign) campaigns;

    function newCampaign(address beneficiary, uint goal) public returns (uint campaignID) {
        campaignID = numCampaigns++; // campaignID is return variable
        // Creates new struct and saves in storage. We leave out the mapping type.
        // è¿™é‡Œæ„é€ å‡½æ•°ç”Ÿæˆçš„æ•°æ®ç±»å‹æ˜¯ memoryï¼Œè€Œ campaigns[campaignID]çš„æ•°æ®ä½ç½®æ˜¯ storageï¼Œåªæœ‰è¿™ç§æ–¹å¼å¯ä»¥éšå¼è‡ªåŠ¨è½¬åŒ–è¿™ä¸¤ç§ data locationã€‚
        campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0);
    }

    function contribute(uint campaignID) public payable {
        Campaign storage c = campaigns[campaignID];
        // Creates a new temporary memory struct, initialised with the given values
        // and copies it over to storage.
        // Note that you can also use Funder(msg.sender, msg.value) to initialise.
        c.funders[c.numFunders++] = Funder({addr: msg.sender, amount: msg.value});
        c.amount += msg.value;
    }

    function checkGoalReached(uint campaignID) public returns (bool reached) {
        Campaign storage c = campaigns[campaignID];
        if (c.amount < c.fundingGoal)
            return false;
        uint amount = c.amount;
        c.amount = 0;
        c.beneficiary.transfer(amount);
        return true;
    }
}
```

struct æœ¬èº«å¯ä»¥å­˜å‚¨æ•°ç»„å’Œæ˜ å°„ï¼Œä¹Ÿå¯ä»¥è¢«è¿™ä¸¤è€…å­˜å‚¨ã€‚å®ƒä¸èƒ½å­˜å‚¨å®ƒè‡ªèº«ç±»å‹çš„å˜é‡ï¼Œstruct çš„å°ºå¯¸å¿…é¡»æ˜¯æœ‰é™çš„ã€‚

#### æ˜ å°„

`mapping(_KeyType => _ValueType)`é‡Œçš„keyç±»å‹ä¸èƒ½æ˜¯æ˜ å°„ï¼ŒåŠ¨æ€é•¿åº¦æ•°ç»„ã€åˆçº¦ã€æšä¸¾å’Œç»“æ„ä½“ã€‚value å¯ä»¥æ˜¯ä»»ä½•ç±»å‹ã€‚

æ˜ å°„å¯ä»¥è¢«è®¤ä¸ºæ˜¯ä¸ªè¢«è™šæ‹Ÿåˆå§‹åŒ–çš„ hash è¡¨ï¼Œæ‰€æœ‰å¯èƒ½çš„é”®éƒ½å­˜åœ¨è€Œä¸”å€¼è¢«åˆå§‹åŒ–ä¸º0å€¼ã€‚å®é™…ä¸Š key æ•°æ®å¹¶ä¸å­˜åœ¨æ˜ å°„é‡Œé¢ï¼Œåªæœ‰å®ƒçš„`keccak256`æ•£åˆ—å€¼è¢«å­˜åœ¨é‡Œé¢ï¼Œç”¨æ¥æŸ¥å€¼ã€‚

```
pragma solidity ^0.4.0;

contract MappingExample {
    mapping(address => uint) public balances;

    function update(uint newBalance) public {
        balances[msg.sender] = newBalance;
    }
}

contract MappingUser {
    function f() public returns (uint) {
        MappingExample m = new MappingExample();
        m.update(100);
        return m.balances(this);
    }
}
```
mapping æœ¬èº«æ˜¯ä¸å¯è¿­ä»£çš„ï¼Œä½†å¯ä»¥çœ‹[iterable mapping][18]ï¼Œçœ‹çœ‹æ€ä¹ˆåœ¨å®ƒä¹‹ä¸Šå»ºç«‹ä¸€ä¸ªå¯è¿­ä»£çš„ç»“æ„ã€‚

#### ç‰µæ¶‰åˆ°å·¦å€¼çš„æ“ä½œç¬¦

##### delete

`delete`ä¸€ä¸ªå˜é‡ï¼Œå·®ä¸å¤šå¯ä»¥è¯´æ˜¯æŠŠä¸€ä¸ªé›¶å€¼èµ‹ç»™å®ƒã€‚é™¤äº†ä¸èƒ½ delete ä¸€ä¸ªæ˜ å°„ä»¥å¤–ï¼Œæ‰€æœ‰ç±»å‹çš„å˜é‡éƒ½å¯ä»¥è¢« deleteã€‚delete åŠ¨æ€æ•°ç»„ä¼šå¾—åˆ°ä¸€ä¸ªé•¿åº¦ä¸º0çš„æ–°åŠ¨æ€æ•°ç»„ï¼Œdelete ä¸€ä¸ªé™æ€æ•°ç»„ä¼šå¾—åˆ°ä¸€ä¸ªé•¿åº¦ç­‰äºåŸé•¿åº¦ï¼Œæ‰€æœ‰å…ƒç´ éƒ½ç­‰äºè¯¥å…ƒç´ ç±»å‹é›¶å€¼çš„æ•°ç»„ï¼Œdelete ä¸€ä¸ªç»“æ„ä½“å˜é‡ï¼Œæ‰€æœ‰çš„æˆå‘˜é™¤äº†æ˜ å°„éƒ½ä¼šå˜æˆ0å€¼ã€‚

```
pragma solidity ^0.4.0;

contract DeleteExample {
    uint data;
    uint[] dataArray;

    function f() public {
        // æ³¨æ„ï¼è¿™é‡Œ x æ‹·è´äº† dataï¼Œè€Œä¸æ˜¯æŠŠä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘äº† dataã€‚
        uint x = data;
        delete x; // sets x to 0, does not affect data
        delete data; // sets data to 0, does not affect x which still holds a copy
        uint[] storage y = dataArray;
        delete dataArray; // this sets dataArray.length to zero, but as uint[] is a complex object, also
        // y is affected which is an alias to the storage object
        // On the other hand: "delete y" is not valid, as assignments to local variables
        // referencing storage objects can only be made from existing storage objects.
    }
}
```

#### åŸºæœ¬æ•°æ®ç±»å‹ä¹‹é—´çš„è½¬æ¢

æ‰€æœ‰çš„æ•°æ®ç±»å‹éƒ½å¯ä»¥è½¬å˜ä¸º`uint160`ï¼Œä¹Ÿå°±å¯ä»¥è½¬å˜ä¸ºåœ°å€ã€‚

æ˜¾å¼è½¬æ¢çš„ä¾‹å­ï¼š

```
uint x = uint(y);
```

#### ç±»å‹æ¨å¯¼

```
uint24 x = 0x123;
var y = x;
```

var ä¸èƒ½ç”¨åœ¨å‡½æ•°å½¢å‚å’Œè¿”å›å€¼ä¸Šã€‚
var åªåœ¨ç¬¬ä¸€æ¬¡èµ‹å€¼æ—¶è¢«æ¨å¯¼å‡ºæ¥ï¼Œæ‰€ä»¥ä»¥ä¸‹å¾ªç¯æ— æ³•ç»ˆæ­¢ï¼š

```
for (var i = 0; i < 2000; i++) { ... }
```
å› ä¸ºç¬¬ä¸€æ¬¡èµ‹å€¼ï¼Œä½¿å¾— i è¢«æ¨å¯¼ä¸º`uint8`ç±»å‹äº†ã€‚

### å•ä½å’Œå…¨å±€å¯ç”¨å˜é‡ ###

#### ä»¥å¤ªå¸çš„å•ä½

å››çº§å•ä½`wei`ï¼Œ`finney`ï¼Œ`szabo` æˆ–è€… `ether`ã€‚`2 ether == 2000 finney`ã€‚

#### æ—¶é—´å•ä½

`seconds`ï¼Œ`minutes`ï¼Œ`hours`ï¼Œ`day`ï¼Œ`weeks`å’Œ`years`ã€‚
å°å¿ƒé—°ç§’ï¼ˆ leap secondsï¼‰é—®é¢˜ã€‚

å·§å¦™ä½¿ç”¨å•ä½æ¥å¯¹æ¯”å½“å‰æ—¶é—´çš„ä¾‹å­ï¼š
```
function f(uint start, uint daysAfter) public {
    if (now >= start + daysAfter * 1 days) {
      // ...
    }
}
```

#### ç‰¹æ®Šçš„å˜é‡å’Œå‡½æ•°

åœ¨å…¨å±€ç©ºé—´é‡Œæ—©å·²å­˜åœ¨ä¸€äº›ç‰¹æ®Šçš„å˜é‡å’Œå‡½æ•°ï¼Œç”¨ä»¥æä¾›åŒºå—é“¾çš„ä¿¡æ¯ï¼š

##### åŒºå—å’Œäº‹åŠ¡å±æ€§

- block.blockhash(uint blockNumber) returns (bytes32)ï¼šä¸€ä¸ªç»™å®šåŒºå—çš„æ•£åˆ—å€¼ - åªå¯¹å½“å‰æœ€è¿‘çš„256ä¸ªåŒºå—å¥æ•ˆã€‚
- block.coinbase (address)ï¼šå½“å‰åŒºå—æŒ–æ˜è€…çš„åœ°å€ã€‚
- block.difficulty (uint)ï¼šå½“å‰åŒºå—çš„éš¾åº¦ã€‚
- block.gaslimit (uint)ï¼šå½“å‰åŒºå—çš„ gaslimitã€‚
- block.number (uint)ï¼šå½“å‰åŒºå—å·
- block.timestamp (uint)ï¼šå½“å‰åŒºå—çš„æ—¶é—´æˆ³ï¼Œä» unix epoch å¼€å§‹çš„ç§’æ•°å½¢å¼ã€‚
- msg.data (bytes)ï¼šå®Œæ•´çš„è°ƒç”¨æ•°æ®ã€‚
- msg.gas (uint)ï¼šå‰©ä½™ gasã€‚
- msg.sender (address)ï¼šå½“å‰è°ƒç”¨çš„æ¶ˆæ¯å‘é€è€…ã€‚
- msg.sig (bytes4)ï¼šcalldata çš„æœ€åˆå››ä¸ªå­—èŠ‚ï¼ˆå‡½æ•°æ ‡è¯†ç¬¦ï¼‰ã€‚
- msg.value (uint)ï¼šæ¶ˆæ¯é™„å¸¦çš„ä»·å€¼æ•°ã€‚
- now (uint)ï¼šæ—¶é—´æˆ³çš„åˆ«åã€‚
- tx.gasprice (uint)ï¼šäº‹åŠ¡çš„ gaspriceã€‚
- tx.origin (address)ï¼šäº‹åŠ¡çš„å‘é€è€… (å®Œæ•´è°ƒç”¨é“¾)ã€‚

msg çš„æ‰€æœ‰æˆå‘˜ï¼Œå¯èƒ½åœ¨æ¯ä¸ªå¤–éƒ¨è°ƒç”¨ä¸­éƒ½å‘ç”Ÿå˜åŒ–ã€‚

##### é”™è¯¯å¤„ç†

`assert(bool condition)`ï¼šå¦‚æœæ¡ä»¶ä¸ä¸ºçœŸæŠ›å‡ºå¼‚å¸¸ã€‚
`require(bool condition)`ï¼šæŠ›å‡ºå¼‚å¸¸å¦‚æœæ¡ä»¶ä¸ä¸ºçœŸï¼Œç”¨æ¥åšè¾“å…¥æ£€æŸ¥ï¼ˆé€šå¸¸é…åˆ modifier ä½¿ç”¨ï¼‰ã€‚
`revert()`ï¼šé€€å‡ºæ‰§è¡Œï¼Œå¹¶ä¸”åè½¬çŠ¶æ€å˜åŒ–ã€‚

##### æ•°å­¦å’Œå¯†ç å­¦å‡½æ•°

- addmod(uint x, uint y, uint k) returns (uint):
compute (x + y) % k where the addition is performed with arbitrary precision and does not wrap around at 2**256. Assert that k != 0 starting from version 0.5.0.
- mulmod(uint x, uint y, uint k) returns (uint):
compute (x * y) % k where the multiplication is performed with arbitrary precision and does not wrap around at 2**256. Assert that k != 0 starting from version 0.5.0.
- keccak256(...) returns (bytes32):
compute the Ethereum-SHA-3 (Keccak-256) hash of the (tightly packed) arguments
- sha256(...) returns (bytes32):
compute the SHA-256 hash of the (tightly packed) arguments
- sha3(...) returns (bytes32):
alias to keccak256
- ripemd160(...) returns (bytes20):
compute RIPEMD-160 hash of the (tightly packed) arguments
- ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address):
recover the address associated with the public key from elliptic curve signature or return zero on error (example usage)

å› ä¸ºâ€œç´§å¯†æ‰“åŒ…â€ï¼Œä»¥ä¸‹å†…å®¹æ˜¯ç›¸ç­‰çš„ï¼š
```
keccak256("ab", "c")
keccak256("abc")
keccak256(0x616263)
keccak256(6382179)
keccak256(97, 98, 99)
```

### è¡¨è¾¾å¼å’Œæ§åˆ¶ç»“æ„ ###

#### è¾“å…¥å‚æ•°å’Œè¾“å‡ºå‚æ•°

##### è¾“å…¥å‚æ•°

å£°æ˜è¾“å…¥å‚æ•°å’Œå£°æ˜å˜é‡ä¸€æ ·ã€‚

##### è¾“å‡ºå‚æ•°

è¾“å‡ºå‚æ•°çš„å®šä¹‰ï¼Œå¾ˆåƒ Golangï¼š

```
pragma solidity ^0.4.16;

contract Simple {
    function arithmetics(uint _a, uint _b)
        public
        pure
        returns (uint o_sum, uint o_product)
    {
        o_sum = _a + _b;
        o_product = _a * _b;
    }
}
```

#### æ§åˆ¶ç»“æ„

é™¤äº† switch å’Œ gotoï¼ŒJavaScript ä¸­æ‰€æœ‰çš„æ§åˆ¶ç»“æ„ Solidity éƒ½æ”¯æŒã€‚

##### å¤šè¿”å›å€¼

æˆ‘ä»¬å·²ç»çœ‹åˆ°å£°æ˜çš„åœ°æ–¹æœ‰å¤šè¿”å›å€¼äº†ï¼Œå¯ä»¥åƒ Golang ä¸€æ ·å†™å¤šè¿”å›å€¼-`return (v0, v1, ..., vn)`ã€‚

#### Function Calls

##### å†…éƒ¨è°ƒç”¨

```
pragma solidity ^0.4.16;

contract C {
    function g(uint a) public pure returns (uint ret) { return f(); }
    function f() internal pure returns (uint ret) { return g(7) + f(); }
}
```

å†…éƒ¨è°ƒç”¨ä¼šè¢« EVM ç¿»è¯‘æˆå­—èŠ‚ç ï¼Œç›´æ¥ jump è¿‡å»ã€‚å› ä¸ºè¿™æ—¶å€™è¿˜æ˜¯åœ¨å†…å­˜å†…è°ƒç”¨ï¼Œå†…å­˜å†…çŠ¶æ€æ²¡æœ‰è¢«æ¸…ç†æ‰ï¼Œæ‰€ä»¥æ˜¯å¾ˆé«˜æ•ˆã€‚

##### å¤–éƒ¨å‡½æ•°è°ƒç”¨

åƒ`c.g(2);`è¿™ç±»è°ƒç”¨ï¼Œæœ¬èº«æ˜¯åœ¨ä¸€ä¸ª contract å®ä¾‹ä¸Šçš„è°ƒç”¨ï¼Œæœ¬èº«å¿…ç„¶è¦æ±‚ message call çš„ï¼Œå°±ä¸èƒ½ jump äº†ã€‚

è°ƒç”¨å…¶ä»–åˆçº¦çš„ payable æ–¹æ³•çš„ä¾‹å­ã€‚

```
pragma solidity ^0.4.0;

contract InfoFeed {
    function info() public payable returns (uint ret) { return 42; }
}

contract Consumer {
    InfoFeed feed;
    function setFeed(address addr) public { feed = InfoFeed(addr); }
    function callFeed() public { feed.info.value(10).gas(800)(); }
}
```

åªæœ‰è¢« payable ä¿®é¥°çš„æ–¹æ³•ï¼Œæ‰å¯ä»¥è¢« value option æ–¹æ³•è°ƒç”¨ã€‚`InfoFeed(addr)`å¹¶ä¸æ˜¯è°ƒç”¨ä¸€ä¸ªæ„é€ æ–¹æ³•ï¼ˆçœ‹æ¥æ„é€ æ–¹æ³•åªæœ‰åœ¨åˆçº¦åˆå§‹åŒ–çš„æ—¶å€™æ‰ä¼šè¢«è°ƒç”¨ï¼‰ï¼Œè€Œæ˜¯å‘è¿™ä¸ªåœ°å€å£°ç§°èƒ½ä¸€ä¸ªä»£ç†å¯¹è±¡ï¼Ÿ

ä¸ä»»ä½•å…¶ä»–åˆçº¦äº¤äº’éƒ½æœ‰æ½œåœ¨å±é™©ï¼Œç‰¹åˆ«æ˜¯åœ¨è¯¥åˆçº¦çš„æºç äº‹å…ˆæœªçŸ¥çš„æƒ…å†µä¸‹ã€‚å½“å‰çš„åˆçº¦æŠŠæ§åˆ¶æƒæ‹±æ‰‹äº¤ç»™è¢«è°ƒç”¨åˆçº¦ï¼Œå®ƒå°±å¯ä»¥åšä»»ä½•äº‹ã€‚ä¸ºäº†è®©è‡ªå·±çš„æˆnot vulnerable to exploitï¼Œåº”è¯¥è®©è‡ªå·±çš„å¤–éƒ¨å‡½æ•°è°ƒç”¨æœ‰é˜²å¾¡æ€§ï¼Œå°½é‡è®©å¤–éƒ¨å‡½æ•°è°ƒç”¨å‘ç”Ÿåœ¨**çŠ¶æ€æ”¹å˜ä¹‹å**ã€‚

##### å‘½åè°ƒç”¨å’ŒåŒ¿åå‡½æ•°å‚æ•°

ä¸€ä¸ªç®€å•çš„å­—é¢é‡è°ƒç”¨çš„ä¾‹å­ï¼š

```
pragma solidity ^0.4.0;

contract C {
    function f(uint key, uint value) public {
        // ...
    }

    function g() public {
        // named arguments
        f({value: 2, key: 3});
    }
}
```

##### çœç•¥å‡½æ•°å‚æ•°å

```
pragma solidity ^0.4.16;

contract C {
    // è¿™é‡Œæœ‰ä¸ªè¢«çœç•¥äº†çš„ uint å‚æ•°ï¼Œä¸èƒ½è®¿é—®åˆ°ã€‚
    // omitted name for parameter
    function func(uint k, uint) public pure returns(uint) {
        return k;
    }
}
```

#### ç”¨`new`åˆ›å»ºæ–°åˆçº¦

å¯ä»¥ç”¨`new`æ¥åˆ›å»ºåˆçº¦ã€‚è¦è¢«åˆ›å»ºçš„åˆçº¦çš„å®Œæ•´ä»£ç ï¼Œè¦äº‹å…ˆè¢«çŸ¥é“ï¼Œæ‰€ä»¥ï¼Œä¹Ÿå°±ä¸å¯èƒ½æœ‰é€’å½’çš„åˆ›å»ºä¾èµ–äº†ï¼š

```
pragma solidity ^0.4.0;

contract D {
    uint x;
    function D(uint a) public payable {
        x = a;
    }
}

contract C {
    // åˆ›å»º C çš„æ—¶å€™ä¸€å¹¶åˆ›å»º D
    D d = new D(4); // will be executed as part of C's constructor

    function createD(uint arg) public {
        D newD = new D(arg);
    }

    function createAndEndowD(uint arg, uint amount) public payable {
        // Send ether along with the creation
        D newD = (new D).value(amount)(arg);
    }
}
```

#### è¡¨è¾¾å¼æ±‚å€¼çš„é¡ºåº

é™¤äº†å¸ƒå°”è¡¨è¾¾å¼ä»¥å¤–ï¼Œæ‰€æœ‰è¡¨è¾¾å¼çš„æ±‚å€¼é¡ºåºéƒ½å¯èƒ½æ˜¯æœªå®šçš„ã€‚åœ¨è¡¨è¾¾å¼æ ‘ä¸­ï¼Œåªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹çš„å­©å­èŠ‚ç‚¹ä¸€å®šä¼šåœ¨å®ƒä¹‹å‰æ‰§è¡Œï¼ˆåç¼€éå†ï¼‰ï¼Œå…¶ä»–çš„å…¨éƒ¨éƒ½æ²¡æœ‰ä¿è¯ã€‚

#### èµ‹å€¼

##### è§£æ„èµ‹å€¼å’Œå¤šè¿”å›å€¼

Solidity å†…éƒ¨æ”¯æŒå…ƒç»„ç±»å‹ï¼Œå³ä¸€ä¸ªå…ƒç´ å¯èƒ½æ˜¯ä¸åŒç±»å‹ï¼Œä½†é•¿åº¦åœ¨ç¼–è¯‘æ—¶å°±å·²ç»ç¡®å®šä¸ºå¸¸æ•°çš„æ•°ç»„åˆ—è¡¨ã€‚å…ƒç»„æ‰æ˜¯å¤šè¿”å›å€¼çš„æœ¬è´¨ï¼ˆå…¶å®åœ¨å…¶ä»–è¯­è¨€é‡Œè¿˜å…è®¸å¯¹è±¡ç»“æ„çš„è§£æ„è¿”å›ï¼‰ã€‚

```
pragma solidity ^0.4.16;

contract C {
    uint[] data;

    function f() public pure returns (uint, bool, uint) {
        return (7, true, 2);
    }

    function g() public {
        // Declares and assigns the variables. Specifying the type explicitly is not possible.
        var (x, b, y) = f();
        // Assigns to a pre-existing variable.
        (x, y) = (2, 7);
        // Common trick to swap values -- does not work for non-value storage types.
        (x, y) = (y, x);
        // Components can be left out (also for variable declarations).
        // If the tuple ends in an empty component,
        // the rest of the values are discarded.
        (data.length,) = f(); // Sets the length to 7
        // The same can be done on the left side.
        // If the tuple begins in an empty component, the beginning values are discarded.
        (,data[3]) = f(); // Sets data[3] to 2
        // Components can only be left out at the left-hand-side of assignments, with
        // one exception:
        (x,) = (1,);
        // (1,) is the only way to specify a 1-component tuple, because (1) is
        // equivalent to 1.
    }
}
```

##### æ•°ç»„å’Œç»“æ„ä½“çš„å¤æ‚ç‚¹

æ•°ç»„å’Œç»“æ„ä½“ç­‰éå€¼ç±»å‹èµ‹å€¼è¯­ä¹‰ç¨æ˜¾å¤æ‚ã€‚

èµ‹å€¼ç»™ä¸€ä¸ªçŠ¶æ€å˜é‡æ€»æ˜¯ä¼šäº§ç”Ÿä¸€ä¸ªç‹¬ç«‹æ‹·è´ã€‚

ä»çŠ¶æ€å˜é‡èµ‹æ•°ç»„å’Œç»“æ„ä½“ç»™å±€éƒ¨å˜é‡æ˜¯ä¼ å¼•ç”¨ï¼Œå†èµ‹å€¼è¿˜æ˜¯ä¼ å¼•ç”¨ã€‚

#### ä½œç”¨åŸŸå’Œå£°æ˜

ä¸€ä¸ªå˜é‡ï¼ˆåŒ…æ‹¬åœ¨å‡½æ•°å†…ï¼‰è¢«å£°æ˜çš„æ—¶å€™å°±ä¼šæ‹¥æœ‰å­—èŠ‚é›¶å€¼ã€‚

```
pragma solidity ^0.4.0;

contract C {
    function foo() public pure returns (uint) {
        // baz is implicitly initialized as 0
        uint bar = 5;
        if (true) {
            bar += baz;
        } else {
            uint baz = 10;// never executes
        }
        return bar;// returns 5
    }
}
```

å‡½æ•°å†…çš„å˜é‡é‡Œè¿˜æ˜¯æ²¡æœ‰å—çº§ä½œç”¨åŸŸçš„ã€‚

##### ä» 0.5.0 å¼€å§‹å°±æœ‰ä½œç”¨åŸŸäº†

å—ä½œç”¨åŸŸæœ‰å—ç”Ÿå‘½å‘¨æœŸã€‚
for ç›¸å…³å˜é‡åªæœ‰ for å—çš„ç”Ÿå‘½å‘¨æœŸã€‚

```
pragma solidity ^0.4.0;
pragma experimental "v0.5.0";
contract C {
    function minimalScoping() pure public {
        {
            uint same2 = 0;
        }

        {
            uint same2 = 0;
        }
    }
}
```

```
pragma solidity ^0.4.0;
pragma experimental "v0.5.0";
contract C {
    function f() pure public returns (uint) {
        uint x = 1;
        {
            x = 2; // this will assign to the outer variable
            uint x;
        }
        return x; // x has value 2
    }
}
```

#### é”™è¯¯å¤„ç†ï¼šæ–­è¨€ã€éœ€æ±‚ã€åè½¬å’Œå¼‚å¸¸

æ‰€æœ‰å¼‚å¸¸éƒ½ä¼šåè½¬å½“å‰çš„è°ƒç”¨åŠå…¶å­è°ƒç”¨çš„çŠ¶æ€å˜åŒ–ã€‚

åœ¨æœªæ¥`throw`ä¼šè¢«æ·˜æ±°æ‰ï¼Œåº”è¯¥ä½¿ç”¨`revert`ã€‚

æœ‰äº›è°ƒç”¨æ–¹æ³•æ˜¯é è¿”å›å€¼æ¥ç¡®è®¤å¼‚å¸¸çš„ï¼Œæ³¨æ„æ£€æŸ¥è¿”å›å€¼ã€‚

ç›®å‰ä¸æ”¯æŒ catch è¯­å¥ã€‚

### åˆçº¦

Solidity é‡Œçš„åˆçº¦ï¼Œç±»ä¼¼é¢å‘å¯¹è±¡è¯­è¨€é‡Œé¢çš„ç±»ã€‚ä»–ä»¬åŒ…å«æŒä¹…åŒ–çŠ¶æ€å’Œä¿®æ”¹çŠ¶æ€çš„å‡½æ•°ã€‚

è·¨åˆçº¦è°ƒç”¨ä¸èƒ½å¼•ç”¨è€ä¸Šä¸‹æ–‡çš„çŠ¶æ€å˜é‡ï¼Œä½†ä¾ç„¶è¦å°å¿ƒå¤–éƒ¨å‡½æ•°è°ƒç”¨é—®é¢˜ã€‚

#### åˆ›å»ºåˆçº¦

å¯ä»¥ç”¨å¤–éƒ¨äº‹åŠ¡æˆ–è€…åœ¨åˆçº¦å†…éƒ¨åˆ›å»ºåˆçº¦ã€‚

å¯ä»¥ç”¨[web3.js][19]çš„ API åˆ›å»ºåˆçº¦ï¼Œå…·ä½“å‚è§[web3.eth.Contract][20]ã€‚

åªå…è®¸ä¸€ä¸ªæ„é€ å‡½æ•°ï¼Œä¸å…è®¸æ„é€ å‡½æ•°é‡è½½ã€‚ä¹Ÿå¯ä»¥æ²¡æœ‰æ„é€ å‡½æ•°ã€‚

```
pragma solidity ^0.4.16;

contract OwnedToken {
    // TokenCreator is a contract type that is defined below.
    // It is fine to reference it as long as it is not used
    // to create a new contract.
    TokenCreator creator;
    address owner;
    bytes32 name;

    // This is the constructor which registers the
    // creator and the assigned name.
    function OwnedToken(bytes32 _name) public {
        // internal å˜é‡ä¸éœ€è¦ this è®¿é—®ï¼Œåæ­£è¿™æ—¶å€™åˆçº¦è¿˜ä¸å­˜åœ¨å‘¢
        // State variables are accessed via their name
        // and not via e.g. this.owner. This also applies
        // to functions and especially in the constructors,
        // you can only call them like that ("internally"),
        // because the contract itself does not exist yet.
        owner = msg.sender;
        // We do an explicit type conversion from `address`
        // to `TokenCreator` and assume that the type of
        // the calling contract is TokenCreator, there is
        // no real way to check that.
        creator = TokenCreator(msg.sender);
        name = _name;
    }

    function changeName(bytes32 newName) public {
        // Only the creator can alter the name --
        // the comparison is possible since contracts
        // are implicitly convertible to addresses.
        if (msg.sender == address(creator))
            name = newName;
    }

    function transfer(address newOwner) public {
        // Only the current owner can transfer the token.
        if (msg.sender != owner) return;
        // We also want to ask the creator if the transfer
        // is fine. Note that this calls a function of the
        // contract defined below. If the call fails (e.g.
        // due to out-of-gas), the execution here stops
        // immediately.
        if (creator.isTokenTransferOK(owner, newOwner))
            owner = newOwner;
    }
}

contract TokenCreator {
    function createToken(bytes32 name)
       public
       returns (OwnedToken tokenAddress)
    {
        // Create a new Token contract and return its address.
        // From the JavaScript side, the return type is simply
        // `address`, as this is the closest type available in
        // the ABI.
        return new OwnedToken(name);
    }

    function changeName(OwnedToken tokenAddress, bytes32 name)  public {
        // Again, the external type of `tokenAddress` is
        // simply `address`.
        tokenAddress.changeName(name);
    }

    function isTokenTransferOK(address currentOwner, address newOwner)
        public
        view
        returns (bool ok)
    {
        // è¿™æ®µå¯ä»¥è¯´æ˜¯èƒ¡è¯Œçš„
        // Check some arbitrary condition.
        address tokenAddress = msg.sender;
        return (keccak256(newOwner) & 0xff) == (bytes20(tokenAddress) & 0xff);
    }
}
```

#### å¯è§æ€§å’Œ Getter

å†…éƒ¨è°ƒç”¨åªäº§ç”Ÿ JUMPï¼Œè€Œå¤–éƒ¨è°ƒç”¨äº§ç”Ÿ EVM callã€‚

æœ‰å››ç§å¯è§æ€§ï¼š`external`ï¼Œ`public`ï¼Œ`internal`æˆ–è€… `private`ã€‚è¿™å››ä¸ªå¯è§æ€§ï¼Œæ°å¥½æ˜¯ä¸¤ç»„åä¹‰è¯ã€‚

çŠ¶æ€å˜é‡é»˜è®¤å¯è§æ€§æ˜¯`internal`è€Œä¸å¯èƒ½æ˜¯`external`ã€‚

**å‡½æ•°é»˜è®¤å¯è§æ€§æ˜¯ publicï¼**

externalï¼šå¤–éƒ¨å‡½æ•°æ˜¯åˆçº¦æ¥å£çš„ä¸€éƒ¨åˆ†ã€‚æ„å‘³ç€ä»–ä»¬åº”è¯¥è¢«ä»å¤–éƒ¨è°ƒç”¨ï¼Œå¿…ç„¶äº§ç”Ÿ EVM callã€‚ä¸€ä¸ª`external`çš„`f`æ˜¯ä¸èƒ½`f()`çš„ï¼Œåªèƒ½`this.f()`ã€‚

publicï¼šå…¬å…±å‡½æ•°ä¹Ÿæ˜¯åˆçº¦æ¥å£çš„ä¸€éƒ¨åˆ†ã€‚å¯ä»¥å¤–éƒ¨è°ƒç”¨ä¹Ÿå¯ä»¥å†…éƒ¨è°ƒç”¨ã€‚æœ€ç®€å•è€Œå®Œç¾çš„æ¥å£è®¾è®¡ã€‚å…¬å…±å˜é‡ä¼šè‡ªåŠ¨äº§ç”Ÿä¸€ä¸ª getter å‡½æ•°ã€‚

internalï¼šå†…éƒ¨å‡½æ•°å’Œå˜é‡åªèƒ½åˆçº¦å†…éƒ¨è®¿é—®ï¼Œä¸ç”¨ thisã€‚ç±»ä¼¼ privateã€‚

privateï¼šå†…éƒ¨å‡½æ•°å’Œå˜é‡ä¸èƒ½è¢«ç»§æ‰¿ï¼Œåªèƒ½å†…éƒ¨è®¿é—®ã€‚

æ³¨æ„ï¼Œåˆçº¦çš„æ‰€æœ‰å†…å®¹åœ¨åŒºå—é“¾ä¸Šéƒ½æ˜¯å…¬å¼€å¯è§çš„ï¼Œè¿™äº›ä¿®é¥°ç¬¦åªèƒ½é˜»æ­¢ä¸å½“ä¿®æ”¹ã€‚

```
// This will not compile
pragma solidity ^0.4.0;

contract C {
    uint private data;

    function f(uint a) private returns(uint b) { return a + 1; }
    function setData(uint a) public { data = a; }
    function getData() public returns(uint) { return data; }
    function compute(uint a, uint b) internal returns (uint) { return a+b; }
}

contract D {
    function readData() public {
        C c = new C();
        uint local = c.f(7); // error: member `f` is not visible
        c.setData(3);
        local = c.getData();
        local = c.compute(3, 5); // error: member `compute` is not visible
    }
}

// é€šè¿‡ç»§æ‰¿ï¼Œå®ç°äº†ä»£ç å¤ç”¨
contract E is C {
    function g() public {
        C c = new C();
        uint val = compute(3, 5); // access to internal member (from derived to parent contract)
    }
}
```

##### Getter

getter æ˜¯è‡ªåŠ¨ç”Ÿæˆçš„ï¼Œä¸€ä¸ªè°ƒç”¨çš„ä¾‹å­ã€‚

```
pragma solidity ^0.4.0;

contract C {
    uint public data = 42;
}

contract Caller {
    C c = new C();
    function f() public {
        // æ¢è¨€ä¹‹ï¼Œç”¨å‡½æ•°æ¥è®¿é—®å…¬å…±å˜é‡ï¼Œä¸è¦ç”¨ç‚¹æ“ä½œç¬¦ã€‚
        uint local = c.data();
    }
}
```

å†…å¤–è®¿é—®ä¸å†…éƒ¨è®¿é—®ï¼š

```
pragma solidity ^0.4.0;

contract C {
    uint public data;
    function x() public {
        data = 3; // internal access
        uint val = this.data(); // external access
    }
}
```
ä¸€ä¸ªæ›´å¤æ‚çš„ä¾‹å­ï¼š

```
pragma solidity ^0.4.0;

contract Complex {
    struct Data {
        uint a;
        bytes3 b;
        mapping (uint => uint) map;
    }
    mapping (uint => mapping(bool => Data[])) public data;
}

```

ç”Ÿæˆçš„å‡½æ•°çš„å½¢å¼å¾ˆè´¹è§£ï¼š

```
function data(uint arg1, bool arg2, uint arg3) public returns (uint a, bytes3 b) {
    a = data[arg1][arg2][arg3].a;
    b = data[arg1][arg2][arg3].b;
}
```

#### å‡½æ•°ä¿®é¥°ç¬¦

å‡½æ•°ä¿®é¥°ç¬¦æ˜¯ç”¨æ¥æ”¹å˜å‡½æ•°è¡Œä¸ºçš„ï¼Œæ¯”å¦‚æ£€éªŒæ¡ä»¶ã€‚å‡½æ•°ä¿®é¥°ç¬¦å¯ä»¥è¢«é›†æˆä¹Ÿå¯ä»¥è¢«è¦†ç›–ã€‚

```
pragma solidity ^0.4.11;

contract owned {
    function owned() public { owner = msg.sender; }
    address owner;

    // This contract only defines a modifier but does not use
    // it: it will be used in derived contracts.
    // The function body is inserted where the special symbol
    // `_;` in the definition of a modifier appears.
    // This means that if the owner calls this function, the
    // function is executed and otherwise, an exception is
    // thrown.
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
}

contract mortal is owned {
    // This contract inherits the `onlyOwner` modifier from
    // `owned` and applies it to the `close` function, which
    // causes that calls to `close` only have an effect if
    // they are made by the stored owner.
    function close() public onlyOwner {
        selfdestruct(owner);
    }
}

contract priced {
    // Modifiers can receive arguments:
    modifier costs(uint price) {
        if (msg.value >= price) {
            _;
        }
    }
}

contract Register is priced, owned {
    mapping (address => bool) registeredAddresses;
    uint price;

    function Register(uint initialPrice) public { price = initialPrice; }
    
    // å¦‚æœæ²¡æœ‰è¿™ä¸ªå…³é”®å­—ï¼Œåˆçº¦ä¼šè‡ªåŠ¨æ‹’ç»è¢«å‘é€è¿‡æ¥çš„ä»¥å¤ªå¸
    // It is important to also provide the
    // `payable` keyword here, otherwise the function will
    // automatically reject all Ether sent to it.
    function register() public payable costs(price) {
        registeredAddresses[msg.sender] = true;
    }

    function changePrice(uint _price) public onlyOwner {
        price = _price;
    }
}

// å·§å¦™åœ°åŠ é”ï¼Œç±»ä¼¼ synchronizedã€‚
contract Mutex {
    bool locked;
    modifier noReentrancy() {
        require(!locked);
        locked = true;
        // è®©æ­¥ä¿®é¥°ç¬¦ï¼Œç±»ä¼¼ Ruby ä¸­çš„ yieldã€‚
        _;
        locked = false;
    }

    /// This function is protected by a mutex, which means that
    /// reentrant calls from within `msg.sender.call` cannot call `f` again.
    /// The `return 7` statement assigns 7 to the return value but still
    /// executes the statement `locked = false` in the modifier.
    function f() public noReentrancy returns (uint) {
        require(msg.sender.call());
        return 7;
    }
}
```

#### çŠ¶æ€å¸¸é‡

çŠ¶æ€å˜é‡å¯ä»¥è¢«å£°æ˜ä¸º`constant`ã€‚å®ƒä»¬å¿…é¡»è¢«ç¼–è¯‘æ—¶å·²çŸ¥å¸¸é‡å€¼çš„è¡¨è¾¾å¼èµ‹å€¼ï¼Œè¡¨è¾¾å¼ä¸èƒ½æ¥è§¦ storage (e.g. `now`ï¼Œ`this.balance` æˆ–è€… `block.number`)ï¼Œä¸èƒ½ç”±æ‰§è¡Œæ•°æ®å†³å®šï¼ˆ`msg.value`æˆ–è€…`gasleft()`ï¼‰ï¼Œæˆ–è€…å¤–éƒ¨åˆçº¦è°ƒç”¨ã€‚å…è®¸ä½¿ç”¨å†…éƒ¨è®¡ç®—å‡½æ•°`keccak256` ï¼Œ`sha256`ï¼Œ`ripemd160`ï¼Œ`ecrecover`ï¼Œ`addmod`å’Œ`mulmod`ã€‚

```
pragma solidity ^0.4.0;

contract C {
    uint constant x = 32**22 + 8;
    string constant text = "abc";
    bytes32 constant myHash = keccak256("abc");
}
```

#### å‡½æ•°

##### view

ä¸ä¿®æ”¹çŠ¶æ€çš„å‡½æ•°å¯ä»¥è¢«å£°æ˜ä¸º`view`ã€‚

ä»¥ä¸‹æƒ…å†µä¸èƒ½ç”¨`view`ï¼š

1. å†™çŠ¶æ€å˜é‡
2. å‘å°„äº‹ä»¶
3. åˆ›å»ºå…¶ä»–åˆçº¦
4. ä½¿ç”¨è‡ªæ¯
5. ç”¨è°ƒç”¨å‘é€ä»¥å¤ªå¸ï¼ˆä¹Ÿå°±æ˜¯è¯´ call ä¹Ÿä¸å®‰å…¨ï¼‰
6. è°ƒç”¨å…¶ä»–é`view`æˆ–è€…`pure`æ–¹æ³•ã€‚
7. ä½¿ç”¨ä½çº§è°ƒç”¨æ–¹æ³•ã€‚
8. ä½¿ç”¨æŸäº›ç‰¹å®šå†…è”æ±‡ç¼–æ“ä½œç ã€‚

```
pragma solidity ^0.4.16;

contract C {
    function f(uint a, uint b) public view returns (uint) {
        return a * (b + 42) + now;
    }
}
```

getter éƒ½æ˜¯`view`ã€‚

view æ˜¯å°½é‡åšåˆ°æœ€å¤§é™åº¦çš„ç¼–ç¨‹å®‰å…¨ï¼Œæœ‰æ—¶å€™åˆä¸èƒ½ä¿è¯ã€‚æ‰€ä»¥æ˜¯ä¸ªæœªå®Œæˆå“ã€‚

##### pure å‡½æ•°

ä¸è¯»å’Œå†™ state çš„å‡½æ•°å« pure å‡½æ•°ã€‚view æ˜¯ä¸å†™ï¼Œpure æ›´å½»åº•ã€‚pure å¯èƒ½äº§ç”Ÿå‰¯ä½œç”¨ï¼Œä¸æ˜¯å‡½æ•°å¼ç¼–ç¨‹é‡Œçš„çº¯å‡½æ•°ã€‚

pure å‡½æ•°é¦–å…ˆå¿…é¡»æ»¡è¶³ view å‡½æ•°çš„è¦æ±‚ï¼Œç„¶åä¸èƒ½æœ‰ä»¥ä¸‹è¡Œä¸ºï¼š

1. è¯»çŠ¶æ€å˜é‡
2. è®¿é—®ä»»ä½• balanceã€‚
3. è®¿é—® blockï¼Œtx å’Œ msg çš„ä»»ä½•æˆå‘˜ã€‚
4. è°ƒç”¨é`pure`çš„å…¶ä»–å‡½æ•°ã€‚
5. ä½¿ç”¨æŸäº›ç‰¹å®šå†…è”æ±‡ç¼–æ“ä½œç ã€‚

pure ä¹Ÿæ˜¯æœªå®Œæˆå“ï¼Œç¼–è¯‘å™¨ä¸èƒ½ä¿è¯å‡½æ•°çš„ä¸è¯»ä¸å†™ã€‚

##### é™çº§å‡½æ•°

ä¸€ä¸ªåˆçº¦åªèƒ½ç”±ä¸€ä¸ªæ— åå‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°ä¸èƒ½æœ‰å‚æ•°åˆ—è¡¨ï¼Œä¹Ÿä¸èƒ½æœ‰è¿”å›å€¼ã€‚åˆçº¦åœ¨è¢«è°ƒç”¨ï¼Œä½†æ²¡æœ‰åˆé€‚çš„å‡½æ•°åŒ¹é…å¾—ä¸Šï¼Œæˆ–è€…æ²¡æœ‰ä»»ä½•è°ƒç”¨æ•°æ®çš„æ—¶å€™ï¼Œè¿™ä¸ªå‡½æ•°å°±è¢«æ´¾ä¸Šç”¨åœºäº†ã€‚

è¿™ä¸ªå‡½æ•°åœ¨åˆçº¦æ¥æ”¶åˆ°çº¯ä»¥å¤ªå¸ï¼ˆæ²¡æœ‰æ•°æ®ï¼‰çš„æ—¶å€™ï¼Œè¿™ä¸ªå‡½æ•°ä¹Ÿä¼šè¢«æ‰§è¡Œã€‚ä¸ºäº†æ¥æ”¶ä»¥å¤ªå¸ï¼Œè¿™ä¸ªå‡½æ•°å¿…é¡»è¢«å£°æ˜ä¸º payableã€‚æ²¡æœ‰è¿™ä¸ªå‡½æ•°ï¼Œæ™®é€šè½¬è´¦äº‹åŠ¡æ— æ³•å¾€è¿™ä¸ªåˆçº¦é‡Œè½¬è´¦ã€‚

è¿™ä¸ªå‡½æ•°æœ€å°‘éœ€è¦ 2300ä¸ª gasï¼ˆæ°å¥½æ˜¯æ™®é€šè½¬è´¦çš„ååˆ†ä¹‹ä¸€ï¼‰ã€‚

å³ä½¿è¿™ä¸ªå‡½æ•°æ²¡æœ‰ä»»ä½•å‚æ•°ï¼Œå®ƒä¹Ÿå¯ä»¥ç”¨`msg.data`æ¥è·å–è°ƒç”¨è½½è·ã€‚æ¢è¨€ä¹‹ï¼Œè°ƒç”¨è¿™ç§å‡½æ•°ï¼Œåº”è¯¥å‘é€ä¸€äº›æ²¡æœ‰å…¶ä»–å‡½æ•°å¯ä»¥åŒ¹é…å¾—ä¸Šçš„å®å‚ã€‚

æ—©ç‰ˆæœ¬çš„ Solidity é‡Œé¢é™çº§å‡½æ•°éƒ½è°ƒç”¨å¤±è´¥çš„è¯ï¼Œæ˜¯ä¸é€€å¸çš„ï¼Œç°åœ¨çš„ç‰ˆæœ¬é€€å¸äº†ã€‚

å³ä½¿æ²¡æœ‰é™çº§å‡½æ•°ï¼Œè‡ªæ¯å’ŒæŒ–çŸ¿çš„ç›®æ ‡ä¾ç„¶å¯ä»¥è®¾ç½®ä¸ºè¿™ä¸ªåˆçº¦è´¦æˆ·ã€‚

```
pragma solidity ^0.4.0;

contract Test {
    // This function is called for all messages sent to
    // this contract (there is no other function).
    // Sending Ether to this contract will cause an exception,
    // because the fallback function does not have the `payable`
    // modifier.
    function() public { x = 1; }
    uint x;
}


// This contract keeps all Ether sent to it with no way
// to get it back.
contract Sink {
    function() public payable { }
}

contract Caller {
    function callTest(Test test) public {
        test.call(0xabcdef01); // hash does not exist
        // results in test.x becoming == 1.

        // The following will not compile, but even
        // if someone sends ether to that contract,
        // the transaction will fail and reject the
        // Ether.
        //test.send(2 ether);
    }
}
```

##### å‡½æ•°é‡è½½

å¤§éƒ¨åˆ†æƒ…å†µä¸‹åŒå…¶ä»–é‡è½½ä¸€æ ·ã€‚

```
// This will not compile
pragma solidity ^0.4.16;

contract A {
    function f(B _in) public pure returns (B out) {
        out = _in;
    }

    function f(address _in) public pure returns (address out) {
        out = _in;
    }
}

contract B {
}
```

è¿™ä¸ªå‡½æ•°ä¹‹æ‰€ä»¥ç¼–è¯‘é”™è¯¯ï¼Œæ˜¯å› ä¸ºç¼–è¯‘åçš„ ABI ç±»å‹éƒ½æ˜¯ addressï¼Œç­‰äºæ²¡æœ‰é‡è½½ã€‚

#### äº‹ä»¶

äº‹ä»¶å…è®¸æ–¹ä¾¿åœ°ä½¿ç”¨ EVM çš„æ—¥å¿—åŸºç¡€è®¾æ–½ã€‚

æ—¥å¿—å¯ä»¥è¢«åœ¨åˆçº¦å†…éƒ¨è¢«ç»§æ‰¿ã€‚æ—¥å¿—ä¸äº‹åŠ¡ã€åˆçº¦å…³è”ï¼Œä¸åŒºå—åŒåœ¨ã€‚

æ—¥å¿—çš„ SPV è¯æ˜æ˜¯å¯ä»¥åšåˆ°çš„ã€‚

æœ€å¤šä¸‰ä¸ªå‚æ•°å¯ä»¥è¢«æ ‡è®°ä¸º`indexed`æ¥ç´¢å¼•ã€‚å…¶å®ç´¢å¼•çš„æŸ¥æ‰¾ï¼Œå¯èƒ½æ˜¯é€šè¿‡æ•£åˆ—å­˜å‚¨å’ŒæŸ¥æ‰¾çš„æ–¹å¼æ¥å®ç°çš„ã€‚æœ¬è´¨ä¸Šå°±æ˜¯æŠŠè¿™ä¸ªå‚æ•°å­˜æˆ topic ç±»å‹çš„æ•°æ®ï¼Œå¯ä»¥è¢«ç±»ä¼¼æµå¤„ç†çš„æœºåˆ¶ç›‘å¬èµ·æ¥ã€‚


äº‹ä»¶çš„æ­£ç»Ÿ watch ç”¨æ³•ï¼š
```
pragma solidity ^0.4.0;

contract ClientReceipt {
    event Deposit(
        address indexed _from,
        bytes32 indexed _id,
        uint _value
    );

    function deposit(bytes32 _id) public payable {
        // Events are emitted using `emit`, followed by
        // the name of the event and the arguments
        // (if any) in parentheses. Any such invocation
        // (even deeply nested) can be detected from
        // the JavaScript API by filtering for `Deposit`.
        emit Deposit(msg.sender, _id, msg.value);
    }
}
```
```
var abi = /* abi as generated by the compiler */;
var ClientReceipt = web3.eth.contract(abi);
var clientReceipt = ClientReceipt.at("0x1234...ab67" /* address */);

var event = clientReceipt.Deposit();

// watch for changes
event.watch(function(error, result){
    // result will contain various information
    // including the argumets given to the `Deposit`
    // call.
    if (!error)
        console.log(result);
});

// Or pass a callback to start watching immediately
var event = clientReceipt.Deposit(function(error, result) {
    if (!error)
        console.log(result);
});
```

##### ä½çº§æ—¥å¿—è®¾æ–½

```
pragma solidity ^0.4.10;

contract C {
    function f() public payable {
        bytes32 _id = 0x420042;
        log3(
            bytes32(msg.value),
            bytes32(0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20),
            bytes32(msg.sender),
            _id
        );
    }
}
```
logn ä¸€å…±å– n+1ä¸ªå‚æ•°ã€‚ç¬¬ä¸€ä¸ªå‚æ•°æ”¾åœ¨ data åŒºï¼Œå…¶ä»–å‚æ•°æ”¾åœ¨ topic åŒºã€‚

##### å…¶ä»–ç†è§£äº‹ä»¶çš„èµ„æº

- [Javascript documentation][21]
- [Example usage of events][22]
- [How to access them in js][23]

#### ç»§æ‰¿

Solidity æ”¯æŒæŸç§ç¨‹åº¦ä¸Šçš„å¤šç»§æ‰¿ï¼Œå®ƒéœ€è¦æ‹·è´åŒ…æ‹¬å¤šæ€åœ¨å†…çš„ä»£ç ã€‚å½“ä¸€ä¸ªåˆçº¦å¤šç»§æ‰¿çš„æ—¶å€™ï¼Œåœ¨é“¾ä¸Šåªåˆ›å»ºä¸€ä»½åˆçº¦ï¼Œå…¶ä»–

æ‰€æœ‰çš„å‡½æ•°è°ƒç”¨éƒ½æ˜¯è™šè°ƒç”¨ã€‚

ç»§æ‰¿ç³»ç»Ÿéå¸¸åƒ Python çš„å…ƒç±»ç»§æ‰¿ã€‚

```
pragma solidity ^0.4.16;

contract owned {
    function owned() { owner = msg.sender; }
    address owner;
}

// åªæœ‰ private ä¸ä¼šè¢«ç»§æ‰¿ä¸‹æ¥
// Use `is` to derive from another contract. Derived
// contracts can access all non-private members including
// internal functions and state variables. These cannot be
// accessed externally via `this`, though.
contract mortal is owned {
    function kill() {
        if (msg.sender == owner) selfdestruct(owner);
    }
}

// æ²¡æœ‰å‡½æ•°ä½“çš„å‡½æ•°ã€‚å…¶åˆçº¦æ˜¯æŠ½è±¡çš„ã€‚å®Œå…¨æ²¡æœ‰å‡½æ•°ä½“çš„åˆçº¦åªèƒ½å½“æ¥å£ç”¨ã€‚
// These abstract contracts are only provided to make the
// interface known to the compiler. Note the function
// without body. If a contract does not implement all
// functions it can only be used as an interface.
contract Config {
    function lookup(uint id) public returns (address adr);
}

contract NameReg {
    function register(bytes32 name) public;
    function unregister() public;
 }

// å¤šç»§æ‰¿ç±»ä¼¼ C++ çš„è™šç»§æ‰¿ï¼Œä¸ä¼šæœ‰å¤šä»½é‡å¤æˆå‘˜ã€‚
// Multiple inheritance is possible. Note that `owned` is
// also a base class of `mortal`, yet there is only a single
// instance of `owned` (as for virtual inheritance in C++).
contract named is owned, mortal {
    function named(bytes32 name) {
        Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
        NameReg(config.lookup(1)).register(name);
    }

    // Functions can be overridden by another function with the same name and
    // the same number/types of inputs.  If the overriding function has different
    // types of output parameters, that causes an error.
    // Both local and message-based function calls take these overrides
    // into account.
    function kill() public {
        if (msg.sender == owner) {
            Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
            NameReg(config.lookup(1)).unregister();
            // It is still possible to call a specific
            // overridden function.
            mortal.kill();
        }
    }
}

// è¿™æ ·è°ƒç”¨æ˜¾å¼æ„é€ å‡½æ•°å°±è®¨åŒäº†
// If a constructor takes an argument, it needs to be
// provided in the header (or modifier-invocation-style at
// the constructor of the derived contract (see below)).
contract PriceFeed is owned, mortal, named("GoldFeed") {
   function updateInfo(uint newInfo) public {
      if (msg.sender == owner) info = newInfo;
   }

   function get() public view returns(uint r) { return info; }

   uint info;
}
```

ä¸€ä¸ªè±å½¢ç»§æ‰¿çš„è®¨åŒé—®é¢˜ï¼š

```
pragma solidity ^0.4.0;

contract owned {
    function owned() public { owner = msg.sender; }
    address owner;
}

contract mortal is owned {
    function kill() public {
        if (msg.sender == owner) selfdestruct(owner);
    }
}

contract Base1 is mortal {
    function kill() public { /* do cleanup 1 */ super.kill(); }
}


contract Base2 is mortal {
    function kill() public { /* do cleanup 2 */ super.kill(); }
}

contract Final is Base1, Base2 {
}
```

ç»§æ‰¿é¡ºåºå¤§æ¦‚æ˜¯Finalï¼ŒBase2ï¼ŒBase1ï¼Œmortalï¼Œownedã€‚

è°ƒç”¨é¡ºåºå¾ˆå¤æ‚ï¼Œéœ€è¦ç”¨çš„æ—¶å€™è¿˜æ˜¯çœ‹æ•™ç¨‹åŸæ–‡å§ã€‚

##### æ„é€ å™¨

æ„é€ å™¨å¯ä»¥æ˜¯`public`ä¹Ÿå¯ä»¥æ˜¯`internal`ã€‚

```
pragma solidity ^0.4.11;

contract A {
    uint public a;
    
    // A å› ä¸ºè¿™ä¸ªæ„é€ å™¨å˜æˆäº†æŠ½è±¡ç±»
    function A(uint _a) internal {
        a = _a;
    }
}

// æ˜¾å¼å®ä¾‹åŒ–
contract B is A(1) {
    function B() public {}
}
```

##### åŸºç±»æ„é€ å™¨å‚æ•°

```
pragma solidity ^0.4.0;

contract Base {
    uint x;
    function Base(uint _x) public { x = _x; }
}

// ç”¨ä¸¤ç§æ–¹æ³•è°ƒç”¨åŸºç±»æ„é€ å™¨
contract Derived is Base(7) {
    // ç¬¬äºŒç§æ–¹æ³•èµ¢äº†
    function Derived(uint _y) Base(_y * _y) public {
    }
}
```

##### å¤šé‡ç»§æ‰¿ä¸çº¿æ€§åŒ–

Solidity å­¦ä¹  Python çš„[C3çº¿æ€§åŒ–][24]æ¥è§£å†³[è±å½¢é—®é¢˜][25]ã€‚

```
// This will not compile

pragma solidity ^0.4.0;

contract X {}
contract A is X {}
contract C is A, X {}
```

##### æŠ½è±¡åˆçº¦

ä¸¤ç§æƒ…å†µä¸‹ä¼šäº§ç”ŸæŠ½è±¡åˆçº¦ï¼š

- æœ‰å‡½æ•°æ²¡æœ‰å‡½æ•°ä½“
- æ„é€ å‡½æ•°æ˜¯`internal`çš„ã€‚

```
pragma solidity ^0.4.0;

contract Feline {
    function utterance() public returns (bytes32);
}

contract Cat is Feline {
    function utterance() public returns (bytes32) { return "miaow"; }
}
```

å¯¹æ¯”

```
// æ— å‡½æ•°ä½“å‡½æ•°
function foo(address) external returns (address);
// å‡½æ•°å˜é‡
function(address) external returns (address) foo;
```

#### æ¥å£

æ¥å£å°±æ˜¯å®Œå…¨æ²¡æœ‰ä»»ä½•å‡½æ•°ä½“çš„åˆçº¦ã€‚å’Œ cpp é‡ŒæŠ½è±¡ç±»åˆ°æ¥å£çš„é¡ºåºæ˜¯ä¸€è‡´çš„ã€‚

è€Œä¸”è¿˜æœ‰ä»¥ä¸‹å¾ˆç†Ÿæ‚‰çš„é™åˆ¶ï¼š

- ä¸èƒ½ç»§æ‰¿å…¶ä»–åˆçº¦å’Œæ¥å£
- ä¸èƒ½å®šä¹‰æ„é€ å™¨
- ä¸èƒ½å®šä¹‰å˜é‡
- ä¸èƒ½å®šä¹‰ç»“æ„ä½“
- ä¸èƒ½å®šä¹‰æšä¸¾

æ¥å£å°±æ˜¯ ABI çš„ç­‰ä»·å½¢å¼ï¼Œä¸¤è€…ä¹‹é—´åº”è¯¥å¯ä»¥æ— æŸäº’è½¬ã€‚

æ¥å£æœ‰è‡ªå·±çš„å…³é”®å­—ã€‚

```
pragma solidity ^0.4.11;

interface Token {
    function transfer(address recipient, uint amount) public;
}
```

ä½¿ç”¨æ¥å£å’Œç»§æ‰¿å…¶ä»–åˆçº¦ä¸€æ ·ï¼Œä¹Ÿå°±æ˜¯éƒ½æ˜¯ is å…³é”®å­—ï¼Œæ²¡æœ‰å…¶ä»–ç”¨æ³•ã€‚

#### åº“

åº“ç±»ä¼¼äºåˆçº¦ã€‚ä»–ä»¬çš„ç›®çš„æ˜¯åªåœ¨ç‰¹å®šçš„åœ°å€ä¸Šéƒ¨ç½²ä¸€æ¬¡ï¼Œç„¶åé€šè¿‡`DELEGATECALL`è°ƒç”¨ã€‚è¿™æ„å‘³ç€ï¼Œåº“å‡½æ•°ä¼šåœ¨å½“å‰åˆçº¦çš„ä¸Šä¸‹æ–‡é‡Œè¢«è°ƒç”¨ï¼Œåè€Œä¸åƒå¤–éƒ¨è°ƒç”¨(ç›´æ¥è°ƒç”¨å…¶ä»–åˆçº¦åœ°å€çš„å®ä¾‹æ–¹æ³•ä¸€æ ·)ï¼Œäº§ç”Ÿ EVM callã€‚å‡½æ•°é‡Œçš„ this éƒ½ä¼šç»‘å®šåˆ°å½“å‰åˆçº¦ï¼Œç±»ä¼¼ bindã€‚

å½“ç„¶ï¼Œä»£ç†è°ƒç”¨æ˜¯åº•å±‚å®ç°çš„ï¼Œåœ¨ä½¿ç”¨ä¸Šæ˜¯çœ‹ä¸å‡ºæ¥çš„ã€‚åº“çš„`internal`å‡½æ•°ï¼Œå¯¹äºè°ƒç”¨å®ƒçš„åˆçº¦ä¹Ÿæ˜¯å¯è§çš„ï¼Œè¿™äº›ä»£ç å°±å¥½åƒæ˜¯ä¸€ä¸ªè¢« mixin è¿›åˆçº¦é‡Œçš„åŸºç±»åˆçº¦ä¸€æ ·ã€‚è°ƒç”¨å†…éƒ¨å‡½æ•°ç”¨çš„æ˜¯`JUMP`è€Œä¸æ˜¯`DELEGATECALL`ã€‚

åœ¨è¿™é‡Œï¼Œåº“æ˜¯ä¸€ä¸ª util å¼çš„ç”¨æ³•ã€‚æ¢è¨€ä¹‹ï¼Œåº“é‡Œå¿…é¡»éƒ½æ˜¯æ˜¯`view`æˆ–è€…`pure`å‡½æ•°ã€‚

```
pragma solidity ^0.4.16;

library Set {
  // We define a new struct datatype that will be used to
  // hold its data in the calling contract.
  struct Data { mapping(uint => bool) flags; }

  // Note that the first parameter is of type "storage
  // reference" and thus only its storage address and not
  // its contents is passed as part of the call.  This is a
  // special feature of library functions.  It is idiomatic
  // to call the first parameter `self`, if the function can
  // be seen as a method of that object.
  function insert(Data storage self, uint value)
      public
      returns (bool)
  {
      if (self.flags[value])
          return false; // already there
      self.flags[value] = true;
      return true;
  }

  function remove(Data storage self, uint value)
      public
      returns (bool)
  {
      if (!self.flags[value])
          return false; // not there
      self.flags[value] = false;
      return true;
  }

  function contains(Data storage self, uint value)
      public
      view
      returns (bool)
  {
      return self.flags[value];
  }
}

contract C {
    Set.Data knownValues;

    function register(uint value) public {
        // The library functions can be called without a
        // specific instance of the library, since the
        // "instance" will be the current contract.
        require(Set.insert(knownValues, value));
    }
    // In this contract, we can also directly access knownValues.flags, if we want.
}
```
åº“ä¹Ÿæœ‰é™åˆ¶ï¼š

- ä¸èƒ½æœ‰çŠ¶æ€å˜é‡
- ä¸èƒ½ç»§æ‰¿å…¶ä»–ä¹Ÿä¸èƒ½è¢«ç»§æ‰¿
- ä¸èƒ½æ¥æ”¶ä»¥å¤ªå¸


#### Using For

`using A for B;` è¡¨æ˜ï¼ŒæŠŠä¸€ä¸ªåº“çš„å‡½æ•°æ·»åŠ åˆ°ä¸€ä¸ªæŒ‡å®šç±»å‹ä¸Šã€‚è¿™å¯¼è‡´äº†è¿™äº›åº“å‡½æ•°å¤šäº†ä¸€ä¸ªï¼ˆéšå¼çš„ï¼‰æ¶ˆæ¯æ¥å—è€…å¯¹è±¡ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ï¼Œè¿™ç±»ä¼¼ Python é‡Œçš„ selfã€‚

`using A for *;`è¡¨æ˜ A çš„åº“å‡½æ•°è¢«é™„ç€ç»™ä»»æ„ç±»å‹ã€‚è¿™å¯èƒ½ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆåº“ä¸èƒ½æœ‰è‡ªå·±çš„ state çš„åŸå› å§ã€‚

æ²¡æœ‰ç”¨åˆ° self çš„ä¸€ä¸ªä¾‹å­ï¼š

```
pragma solidity ^0.4.16;

library BigInt {

    // è¿™ä¸ªç»“æ„ä½“æœ¬æ¥æ˜¯æ²¡æœ‰æˆå‘˜å‡½æ•°çš„ã€‚
    struct bigint {
        uint[] limbs;
    }

    // å…¨éƒ¨éƒ½æ˜¯ pure å‡½æ•°
    function fromUint(uint x) internal pure returns (bigint r) {
        r.limbs = new uint[](1);
        r.limbs[0] = x;
    }

    function add(bigint _a, bigint _b) internal pure returns (bigint r) {
        r.limbs = new uint[](max(_a.limbs.length, _b.limbs.length));
        uint carry = 0;
        for (uint i = 0; i < r.limbs.length; ++i) {
            uint a = limb(_a, i);
            uint b = limb(_b, i);
            r.limbs[i] = a + b + carry;
            if (a + b < a || (a + b == uint(-1) && carry > 0))
                carry = 1;
            else
                carry = 0;
        }
        if (carry > 0) {
            // too bad, we have to add a limb
            uint[] memory newLimbs = new uint[](r.limbs.length + 1);
            for (i = 0; i < r.limbs.length; ++i)
                newLimbs[i] = r.limbs[i];
            newLimbs[i] = carry;
            r.limbs = newLimbs;
        }
    }

    function limb(bigint _a, uint _limb) internal pure returns (uint) {
        return _limb < _a.limbs.length ? _a.limbs[_limb] : 0;
    }

    function max(uint a, uint b) private pure returns (uint) {
        return a > b ? a : b;
    }
}

contract C {
    using BigInt for BigInt.bigint;

    function f() public pure {
        // è¿™é‡Œçš„ä¸‰ä¸ªå˜é‡ç±»å‹éƒ½æ˜¯ BigInt.bigintï¼Œä½†å¢åŠ äº†åº“å‡½æ•°
        var x = BigInt.fromUint(7);
        var y = BigInt.fromUint(uint(-1));
        var z = x.add(y);
    }
}
```

self å¯ä»¥ä¸æ˜¯å¿…é¡»çš„ï¼Œä¹Ÿå¯ä»¥æœ‰ï¼Œå¦ä¸€ä¸ªä¾‹å­ï¼š

```
pragma solidity ^0.4.16;

// This is the same code as before, just without comments
library Set {
  struct Data { mapping(uint => bool) flags; }

  function insert(Data storage self, uint value)
      public
      returns (bool)
  {
      if (self.flags[value])
        return false; // already there
      self.flags[value] = true;
      return true;
  }

  function remove(Data storage self, uint value)
      public
      returns (bool)
  {
      if (!self.flags[value])
          return false; // not there
      self.flags[value] = false;
      return true;
  }

  function contains(Data storage self, uint value)
      public
      view
      returns (bool)
  {
      return self.flags[value];
  }
}

contract C {
    using Set for Set.Data; // this is the crucial change
    // ç”¨åå­—ç©ºé—´æ¥è®¿é—®å†…éƒ¨ç±»å‹
    Set.Data knownValues;

    function register(uint value) public {
        // Here, all variables of type Set.Data have
        // corresponding member functions.
        // The following function call is identical to
        // `Set.insert(knownValues, value)`
        // ä»ç¬¬äºŒä¸ªå‚æ•°ä¼ èµ·
        require(knownValues.insert(value));
    }
}
```

å¯¹åŸºç¡€ç±»å‹çš„çŒ´å­è¡¥ä¸ï¼š

```
pragma solidity ^0.4.16;

library Search {
    function indexOf(uint[] storage self, uint value)
        public
        view
        returns (uint)
    {
        for (uint i = 0; i < self.length; i++)
            if (self[i] == value) return i;
        return uint(-1);
    }
}

contract C {
    using Search for uint[];
    uint[] data;

    function append(uint value) public {
        data.push(value);
    }

    function replace(uint _old, uint _new) public {
        // This performs the library function call
        uint index = data.indexOf(_old);
        if (index == uint(-1))
            data.push(_new);
        else
            data[index] = _new;
    }
}
```

### Solidity æ±‡ç¼–

Solidity æ”¯æŒæ‰‹å†™æ±‡ç¼–æ¨¡å¼ã€‚

### æ‚é¡¹

#### æœ‰ç”¨çš„å°æŠ€å·§

- ä½¿ç”¨`delete`åˆ é™¤æ‰€æœ‰çš„æ•°ç»„å…ƒç´ ã€‚
- è°ƒç”¨å†…éƒ¨ send çš„æ–¹æ³•æ˜¯`address(contractVariable).send(amount)`ã€‚
- ç”¨å­—é¢é‡çš„æ–¹æ³•åˆå§‹åŒ–ç»“æ„ä½“ï¼ˆè€Œä¸æ˜¯åˆçº¦ï¼‰ï¼š`x = MyStruct({a: 1, b: 2});`ã€‚

## å®‰å…¨é—®é¢˜

### å¯é‡å…¥

æ‰€æœ‰çš„ send æœ¬è´¨ä¸Šéƒ½å¯ä»¥åŒ…å«ä»£ç æ‰§è¡Œï¼ˆå› ä¸ºé™çº§å‡½æ•°çš„å­˜åœ¨ï¼‰ï¼Œæ‰€æœ‰ä»¥ä¸‹ä¸¤ä¸ªåˆçº¦éƒ½æ˜¯æœ‰æ¼æ´çš„ï¼š

```
pragma solidity ^0.4.0;

// THIS CONTRACT CONTAINS A BUG - DO NOT USE
contract Fund {
    /// Mapping of ether shares of the contract.
    mapping(address => uint) shares;
    /// Withdraw your share.
    function withdraw() public {
        if (msg.sender.send(shares[msg.sender]))
            shares[msg.sender] = 0;
    }
}
```
```
pragma solidity ^0.4.0;

// THIS CONTRACT CONTAINS A BUG - DO NOT USE
contract Fund {
    /// Mapping of ether shares of the contract.
    mapping(address => uint) shares;
    /// Withdraw your share.
    function withdraw() public {
        if (msg.sender.call.value(shares[msg.sender])())
            shares[msg.sender] = 0;
    }
}
```

è¢«è°ƒç”¨æ–¹å¦‚æœåœ¨è‡ªå·±çš„é™çº§å‡½æ•°é‡Œé¢å†è°ƒç”¨è¿™ä¸ªåˆçº¦çš„æå–å‡½æ•°ï¼Œé‚£ä¹ˆå®ƒå¯ä»¥æ— é™æå–é’±ï¼Œç›´åˆ° out-of-gas å¼‚å¸¸å‘ç”Ÿä¸ºæ­¢ã€‚

```
pragma solidity ^0.4.11;

contract Fund {
    /// Mapping of ether shares of the contract.
    mapping(address => uint) shares;
    /// Withdraw your share.
    function withdraw() public {
        var share = shares[msg.sender];
        shares[msg.sender] = 0;
        msg.sender.transfer(share);
    }
}
```

åªæœ‰è¿™ä¸ªå…ˆæ‰£æ¬¾çš„é’±åŒ…æ‰èƒ½é˜²åˆ«äººåå‘é€’å½’è°ƒç”¨è‡ªå·±ã€‚

### è½¬ä»¥å¤ªå¸ç›¸å…³é—®é¢˜

ä¸€ä¸ªåœ°å€å’Œè´¦æˆ·æ²¡æœ‰åŠæ³•æŠ—æ‹’åˆ«äººå‘å®ƒè½¬è´¦ï¼Œé™¤éè½¬è´¦å¤±è´¥ã€‚ä¸ç”¨æ¶ˆæ¯è°ƒç”¨ä¹Ÿå¯ä»¥ç§»åŠ¨ä»¥å¤ªå¸çš„æ–¹æ³•æœ‰ä¸¤ä¸ªï¼šæŒ–çŸ¿å’Œè‡ªæ¯ã€‚

`addr.call.value(x)()`ç­‰ä»·äº`addr.transfer(x)`ï¼Œä½†å®ƒæŠŠå‰©ä½™çš„ gas å…¨éƒ½æä¾›ç»™æ¥å—è€…ï¼Œè®©å®ƒæ‰§è¡Œæ›´è´µçš„æ“ä½œäº†ã€‚

ä¸€å®šè¦è®°å¾—æ£€æŸ¥`send`çš„è¿”å›å€¼ã€‚

### tx.origin

ä¸€ä¸ªç±»ä¼¼ CSRF çš„ç›¸å…³é—®é¢˜ï¼š

ä¸€ä¸ªæ£€æŸ¥ tx.origin çš„é’±åŒ…
```
pragma solidity ^0.4.11;

// THIS CONTRACT CONTAINS A BUG - DO NOT USE
contract TxUserWallet {
    address owner;

    function TxUserWallet() public {
        owner = msg.sender;
    }

    function transferTo(address dest, uint amount) public {
        require(tx.origin == owner);
        dest.transfer(amount);
    }
}

```

ä¸€ä¸ªæ”»å‡»è€…çš„é’±åŒ…

```
pragma solidity ^0.4.11;

interface TxUserWallet {
    function transferTo(address dest, uint amount) public;
}

contract TxAttackWallet {
    address owner;

    function TxAttackWallet() public {
        owner = msg.sender;
    }

    function() public {
        TxUserWallet(msg.sender).transferTo(owner, msg.sender.balance);
    }
}
```

åªè¦è¢«æ”»å‡»è€…å¾€æ”»å‡»è€…é’±åŒ…è½¬è´¦ï¼Œæ”»å‡»è€…é’±åŒ…å°±ä¼šå‘ä¸€ä¸ªæ–°çš„äº‹åŠ¡ï¼Œå¹¶å€Ÿç”¨ tx.origin æ¥ç›—å–è¢«æ”»å‡»è€…çš„å…¨éƒ¨ä½™é¢ã€‚æ¯ä¸ªåœ°å€çš„å…¨éƒ¨ä½™é¢éƒ½æ˜¯å…¬å¼€å¯æŸ¥çš„ã€‚

## é€šç”¨æ¨¡å¼

### ä»åˆçº¦ä¸­å–é’±

æ¯”è°æ›´æœ‰é’±çš„åˆçº¦ï¼š

```
pragma solidity ^0.4.11;

contract WithdrawalContract {
    address public richest;
    uint public mostSent;

    mapping (address => uint) pendingWithdrawals;

    function WithdrawalContract() public payable {
        richest = msg.sender;
        mostSent = msg.value;
    }

    function becomeRichest() public payable returns (bool) {
        if (msg.value > mostSent) {
            pendingWithdrawals[richest] += msg.value;
            richest = msg.sender;
            mostSent = msg.value;
            return true;
        } else {
            return false;
        }
    }

    function withdraw() public {
        uint amount = pendingWithdrawals[msg.sender];
        // Remember to zero the pending refund before
        // sending to prevent re-entrancy attacks
        pendingWithdrawals[msg.sender] = 0;
        msg.sender.transfer(amount);
    }
}
```

### ç”¨ modifier æ¥è®¾å®šå¯è®¿é—®æ€§çš„é—®é¢˜

```
pragma solidity ^0.4.11;

contract AccessRestriction {
    // These will be assigned at the construction
    // phase, where `msg.sender` is the account
    // creating this contract.
    address public owner = msg.sender;
    uint public creationTime = now;

    // Modifiers can be used to change
    // the body of a function.
    // If this modifier is used, it will
    // prepend a check that only passes
    // if the function is called from
    // a certain address.
    modifier onlyBy(address _account)
    {
        require(msg.sender == _account);
        // Do not forget the "_;"! It will
        // be replaced by the actual function
        // body when the modifier is used.
        _;
    }

    /// Make `_newOwner` the new owner of this
    /// contract.
    function changeOwner(address _newOwner)
        public
        onlyBy(owner)
    {
        owner = _newOwner;
    }

    modifier onlyAfter(uint _time) {
        require(now >= _time);
        _;
    }

    /// Erase ownership information.
    /// May only be called 6 weeks after
    /// the contract has been created.
    function disown()
        public
        onlyBy(owner)
        onlyAfter(creationTime + 6 weeks)
    {
        delete owner;
    }

    // This modifier requires a certain
    // fee being associated with a function call.
    // If the caller sent too much, he or she is
    // refunded, but only after the function body.
    // This was dangerous before Solidity version 0.4.0,
    // where it was possible to skip the part after `_;`.
    modifier costs(uint _amount) {
        require(msg.value >= _amount);
        _;
        if (msg.value > _amount)
            msg.sender.send(msg.value - _amount);
    }

    function forceOwnerChange(address _newOwner)
        public
        costs(200 ether)
    {
        owner = _newOwner;
        // just some example condition
        if (uint(owner) & 0 == 1)
            // This did not refund for Solidity
            // before version 0.4.0.
            return;
        // refund overpaid fees
    }
}
```

### çŠ¶æ€æœº

è¿™ä¸ªä¾‹å­æœ‰ä¸¤ä¸ªæœ‰æ„æ€çš„åœ°æ–¹ï¼š
- modifier å¯ä»¥å åŠ 
- å¯ä»¥ç”±æ—¶é—´è‡ªåŠ¨é©±åŠ¨çŠ¶æ€æœºæ‰§è¡Œ

```
pragma solidity ^0.4.11;

contract StateMachine {
    enum Stages {
        AcceptingBlindedBids,
        RevealBids,
        AnotherStage,
        AreWeDoneYet,
        Finished
    }

    // This is the current stage.
    Stages public stage = Stages.AcceptingBlindedBids;

    uint public creationTime = now;

    modifier atStage(Stages _stage) {
        require(stage == _stage);
        _;
    }

    function nextStage() internal {
        stage = Stages(uint(stage) + 1);
    }
    
    // å¿…é¡»æ”¾åœ¨æœ€å¼€å§‹
    // Perform timed transitions. Be sure to mention
    // this modifier first, otherwise the guards
    // will not take the new stage into account.
    modifier timedTransitions() {
        if (stage == Stages.AcceptingBlindedBids &&
                    now >= creationTime + 10 days)
            nextStage();
        if (stage == Stages.RevealBids &&
                now >= creationTime + 12 days)
            nextStage();
        // The other stages transition by transaction
        _;
    }

    // Order of the modifiers matters here!
    function bid()
        public
        payable
        timedTransitions
        atStage(Stages.AcceptingBlindedBids)
    {
        // We will not implement that here
    }

    function reveal()
        public
        timedTransitions
        atStage(Stages.RevealBids)
    {
    }

    // This modifier goes to the next stage
    // after the function is done.
    modifier transitionNext()
    {
        _;
        nextStage();
    }

    function g()
        public
        timedTransitions
        atStage(Stages.AnotherStage)
        transitionNext
    {
    }

    function h()
        public
        timedTransitions
        atStage(Stages.AreWeDoneYet)
        transitionNext
    {
    }

    function i()
        public
        timedTransitions
        atStage(Stages.Finished)
    {
    }
}
```


  [1]: https://stackoverflow.com/questions/48219716/what-is-address0-in-solidity
  [2]: http://solidity.readthedocs.io/en/develop/structure-of-a-contract.html#structure-state-variables
  [3]: http://solidity.readthedocs.io/en/develop/structure-of-a-contract.html#structure-functions
  [4]: http://solidity.readthedocs.io/en/develop/structure-of-a-contract.html#structure-function-modifiers
  [5]: http://solidity.readthedocs.io/en/develop/structure-of-a-contract.html#structure-events
  [6]: http://solidity.readthedocs.io/en/develop/structure-of-a-contract.html#structure-struct-types
  [7]: http://solidity.readthedocs.io/en/develop/structure-of-a-contract.html#structure-enum-types
  [8]: http://solidity.readthedocs.io/en/develop/control-structures.html#function-calls
  [9]: http://solidity.readthedocs.io/en/develop/contracts.html#visibility-and-getters
  [10]: http://solidity.readthedocs.io/en/develop/contracts.html#modifiers
  [11]: http://solidity.readthedocs.io/en/develop/types.html#type-deduction
  [12]: http://solidity.readthedocs.io/en/develop/types.html#arrays
  [13]: http://solidity.readthedocs.io/en/develop/types.html#arrays
  [14]: http://solidity.readthedocs.io/en/develop/abi-spec.html#abi-function-selector
  [15]: http://solidity.readthedocs.io/en/develop/structure-of-a-contract.html#structure-events
  [16]: https://stackoverflow.com/questions/48219716/what-is-address0-in-solidity
  [17]: https://stackoverflow.com/questions/48219716/what-is-address0-in-solidity
  [18]: https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol
  [19]: https://github.com/ethereum/web3.js
  [20]: https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract
  [21]: https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events
  [22]: https://github.com/debris/smart-exchange/blob/master/lib/contracts/SmartExchange.sol
  [23]: https://github.com/debris/smart-exchange/blob/master/lib/exchange_transactions.js
  [24]: https://en.wikipedia.org/wiki/C3_linearization
  [25]: https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem